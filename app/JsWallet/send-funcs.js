// Generated by LiveScript 1.6.0
(function(){
  var toJS, ref$, times, minus, div, plus, createTransaction, pushTx, changeAmountCalcFiat, changeAmountSend, changeAmount, calcCryptoFromEur, calcCryptoFromUsd, changeAmountWithoutFee, notifyFormResult, getNameMask, resolveAddress, window, navigate, bignumber, close, round, round5, round5edit, roundNumber, topup, getPrimaryInfo, createPendingTx, rebuildHistory, map, find, web3, calcFee, confirm, getLang, applyTransactions, getTxDetails, BN, bs58, assert, out$ = typeof exports != 'undefined' && exports || this;
  toJS = require('mobx').toJS;
  ref$ = require('./math.js'), times = ref$.times, minus = ref$.minus, div = ref$.div, plus = ref$.plus;
  ref$ = require('./api.js'), createTransaction = ref$.createTransaction, pushTx = ref$.pushTx;
  ref$ = require('./calc-amount.js'), changeAmountCalcFiat = ref$.changeAmountCalcFiat, changeAmountSend = ref$.changeAmountSend, changeAmount = ref$.changeAmount, calcCryptoFromEur = ref$.calcCryptoFromEur, calcCryptoFromUsd = ref$.calcCryptoFromUsd, changeAmountWithoutFee = ref$.changeAmountWithoutFee;
  notifyFormResult = require('./send-form.js').notifyFormResult;
  getNameMask = require('./get-name-mask.js');
  resolveAddress = require('./resolve-address.js');
  window = require('./browser/window.js');
  navigate = require('./navigate.js');
  bignumber = require('bignumber.js');
  close = require('./close.js');
  round = require('./round.js');
  round5 = require('./round5.js');
  round5edit = require('./round5edit.js');
  roundNumber = require('./round-number.js');
  topup = require('./topup.js');
  getPrimaryInfo = require('./get-primary-info.js');
  createPendingTx = require('./pending-tx.js').createPendingTx;
  rebuildHistory = require('./transactions.js').rebuildHistory;
  ref$ = require('prelude-ls'), map = ref$.map, find = ref$.find;
  web3 = require('./web3.js');
  calcFee = require('./api.js').calcFee;
  confirm = require('./pages/confirmation.js').confirm;
  getLang = require('./get-lang.js');
  applyTransactions = require('./apply-transactions.js');
  getTxDetails = require('./get-tx-details.js');
  BN = require('ethereumjs-util').BN;
  bs58 = require('bs58');
  assert = require('assert');
  module.exports = function(store, web3t){
    var lang, sendTo, send, wallet, feeType, color, primaryButtonStyle, defaultButtonStyle, sendTx, performSendSafe, performSendUnsafe, checkEnough, sendMoney, sendEscrow, executeContractData, beforeSendAnyway, sendAnyway, toHex, cancel, recipientChange, getValue, amountChange, performAmountEurChange, performAmountUsdChange, amountEurChange, amountUsdChange, encodeDecode, showData, showLabel, whenEmpty, history, network, invoice, token, name, ref$, feeToken, isData, bridgeFeeToken, chooseAuto, chooseCheap, chooseCustom, chosenCheap, chosenAuto, chosenCustom, sendOptions, pending, calcAmountAndFee, flag, useMax, useMaxTryCatch, useMaxAmount, hasSendError;
    if (store == null || web3t == null) {
      return null;
    }
    lang = getLang(store);
    sendTo = web3t.naming.sendTo;
    send = store.current.send;
    wallet = send.wallet, feeType = send.feeType;
    if (wallet == null) {
      return null;
    }
    color = getPrimaryInfo(store).color;
    primaryButtonStyle = {
      background: color
    };
    defaultButtonStyle = {
      color: color
    };
    sendTx = function(arg$, cb){
      var to, wallet, network, amountSend, amountSendFee, data, coin, txType, gas, gasPrice, swap, token, currentNetwork, isErc20, chainId, chosenNetwork, receiver, ref$, recipient, txObj;
      to = arg$.to, wallet = arg$.wallet, network = arg$.network, amountSend = arg$.amountSend, amountSendFee = arg$.amountSendFee, data = arg$.data, coin = arg$.coin, txType = arg$.txType, gas = arg$.gas, gasPrice = arg$.gasPrice, swap = arg$.swap;
      token = send.coin.token;
      currentNetwork = store.current.network;
      isErc20 = ['vlx_erc20', 'eth', 'etc', 'sprkl', 'vlx2'].indexOf(token) >= 0;
      chainId = currentNetwork === 'testnet' && isErc20 ? 3 : 1;
      chosenNetwork = store.current.send.chosenNetwork;
      receiver = (ref$ = store.current.send.contractAddress) != null ? ref$ : to;
      recipient = (function(){
        switch (false) {
        case !(chosenNetwork != null && chosenNetwork.id === 'legacy'):
          return toEthAddress(receiver);
        default:
          return receiver;
        }
      }());
      txObj = {
        account: {
          address: wallet.address,
          privateKey: wallet.privateKey,
          secretKey: wallet.secretKey
        },
        recipient: recipient,
        network: network,
        token: token,
        coin: coin,
        amount: amountSend,
        amountFee: amountSendFee,
        data: data,
        gas: gas,
        gasPrice: gasPrice,
        feeType: feeType,
        swap: swap
      };
      if (isErc20) {
        importAll$(txObj, {
          chainId: chainId
        });
      }
      console.log("Prepared tx-obj", txObj);
      return createTransaction(txObj, function(err, txData){
        var parts;
        if (err != null) {
          return cb(err);
        }
        parts = getTxDetails(store);
        return confirm(store, parts[0], function(agree){
          if (!agree) {
            return cb(null);
          }
          return pushTx((import$({
            token: token,
            txType: txType,
            network: network
          }, txData)), function(err, tx){
            if (err != null) {
              return cb(err);
            }
            return createPendingTx({
              store: store,
              token: token,
              network: network,
              tx: tx,
              amountSend: amountSend,
              amountSendFee: amountSendFee,
              to: send.to,
              from: wallet.address
            }, function(err){
              return cb(err, tx);
            });
          });
        });
      });
    };
    performSendSafe = function(cb){
      return resolveAddress({
        store: store,
        address: send.to,
        coin: send.coin,
        network: send.network
      }, function(err, to){
        var _coin, resolved;
        _coin = send.coin.token === 'vlx2'
          ? 'vlx'
          : send.coin.token;
        if (err != null && err.indexOf("Invalid checksum")) {
          err = "Address is not valid " + _coin + " address";
        }
        resolved = (function(){
          switch (false) {
          case err == null:
            return send.to;
          default:
            return to;
          }
        }());
        send.to = resolved;
        if (err != null) {
          send.error = err;
        }
        if (err != null) {
          return cb(err);
        }
        return sendTx((import$({
          wallet: wallet
        }, send)), cb);
      });
    };
    performSendUnsafe = function(cb){
      return sendTx((import$({
        wallet: wallet
      }, send)), cb);
    };
    checkEnough = function(cb){
      var amount, ref$, err;
      try {
        amount = minus(minus(minus(wallet.balance, send.amountSend), (ref$ = wallet.pendingSent) != null ? ref$ : 0), send.amountSendFee);
        if (+amount < 0) {
          return cb("Not Enough funds");
        }
        return cb(null);
      } catch (e$) {
        err = e$;
        return cb(err);
      }
    };
    sendMoney = function(){
      if (wallet.balance === '...') {
        return;
      }
      if (send.sending === true) {
        return;
      }
      return checkEnough(function(err){
        var ref$;
        if (err != null) {
          return send.error = ((ref$ = err.message) != null ? ref$ : err) + "";
        }
        send.sending = true;
        return performSendSafe(function(err, data){
          var ref$;
          send.sending = false;
          if (err != null) {
            return send.error = ((ref$ = err.message) != null ? ref$ : err) + "";
          }
          if (data == null) {
            return null;
          }
          notifyFormResult(send.id, null, data);
          store.current.lastTxUrl = (function(){
            switch (false) {
            case !send.network.api.linktx:
              return send.network.api.linktx.replace(':hash', data);
            case !send.network.api.url:
              return send.network.api.url + "/tx/" + data;
            }
          }());
          navigate(store, web3t, 'sent');
          return web3t.refresh(function(){});
        });
      });
    };
    sendEscrow = function(){
      var name, amountEthers;
      name = send.to;
      amountEthers = send.amountSend;
      return sendTo({
        name: name,
        amountEthers: amountEthers
      }, function(err){});
    };
    executeContractData = function(cb){
      var chosenNetwork, token, ref$, wallet, contractAddress, data, networkType, value, sendTo, tokenAddress, network, minPerTxRaw, minPerTx, maxPerTxRaw, maxPerTx, homeFeeRaw, homeFee, contractHomeFee, minAmountPerTx, receiver, amountToSend, ONE_PERCENT, $recipient, hex, err, ethAddress;
      if (store.current.send.chosenNetwork == null) {
        return cb(null);
      }
      chosenNetwork = store.current.send.chosenNetwork;
      token = store.current.send.coin.token;
      if (((ref$ = chosenNetwork.id) === 'evm' || ref$ === 'legacy') && (token === 'vlx_evm' || token === 'vlx2')) {
        store.current.send.contractAddress = null;
        return cb(null);
      }
      wallet = store.current.send.wallet;
      contractAddress = store.current.send.contractAddress;
      data = "";
      networkType = store.current.network;
      /* Swap from ERC20 to LEGACY (VLX) */
      if (token === 'vlx_erc20' && chosenNetwork.id === 'legacy') {
        console.log("Swap from ERC20 to LEGACY (VLX)");
        send.swap = true;
        value = store.current.send.amountSend;
        sendTo = web3t.velas.ForeignBridgeNativeToErc.address;
        value = toHex(times(value, Math.pow(10, 18)));
        tokenAddress = web3t.velas.ERC20BridgeToken.address;
        network = wallet.network;
        minPerTxRaw = web3t.velas.HomeBridgeNativeToErc.minPerTx();
        minPerTx = div(minPerTxRaw, Math.pow(10, network.decimals));
        console.log("home minPerTxRaw", minPerTxRaw);
        maxPerTxRaw = web3t.velas.HomeBridgeNativeToErc.maxPerTx();
        maxPerTx = div(maxPerTxRaw, Math.pow(10, network.decimals));
        console.log("Home maxPerTxRaw", maxPerTxRaw);
        homeFeeRaw = web3t.velas.ForeignBridgeNativeToErc.getHomeFee();
        homeFee = div(homeFeeRaw, Math.pow(10, network.decimals));
        contractHomeFee = times(send.amountSend, homeFee);
        minAmountPerTx = plus(minPerTx, contractHomeFee);
        console.log("minAmountPerTx", minAmountPerTx);
        if (+send.amountSend < +minAmountPerTx) {
          return cb("Min amount per transaction is " + minAmountPerTx + " VLX");
        }
        if (+send.amountSend > +maxPerTx) {
          return cb("Max amount per transaction is " + maxPerTx + " VLX");
        }
        data = web3t.velas.ERC20BridgeToken.transferAndCall.getData(sendTo, value, toEthAddress(send.to));
        send.data = data;
        send.contractAddress = web3t.velas.ERC20BridgeToken.address;
        send.amount = 0;
        send.amountSend = 0;
      }
      /* Swap from LEGACY (VLX) to ERC20 */
      if (token === 'vlx2' && chosenNetwork.id === 'vlx_erc20') {
        store.current.send.contractAddress = chosenNetwork.HomeBridge;
        receiver = store.current.send.to;
        network = wallet.network;
        minPerTxRaw = web3t.velas.HomeBridgeNativeToErc.minPerTx();
        minPerTx = div(minPerTxRaw, Math.pow(10, network.decimals));
        maxPerTxRaw = web3t.velas.HomeBridgeNativeToErc.maxPerTx();
        maxPerTx = div(maxPerTxRaw, Math.pow(10, network.decimals));
        console.log("maxPerTxRaw", maxPerTxRaw);
        homeFeeRaw = web3t.velas.HomeBridgeNativeToErc.getHomeFee();
        homeFee = div(homeFeeRaw, Math.pow(10, network.decimals));
        console.log("relay tokens to receiver", receiver);
        data = web3t.velas.HomeBridgeNativeToErc.relayTokens.getData(receiver);
        amountToSend = plus(send.amountSendFee, send.amountSend);
        contractHomeFee = times(send.amountSend, homeFee);
        console.log("contract-home-fee", contractHomeFee);
        ONE_PERCENT = times(minPerTx, "0.01");
        minAmountPerTx = plus(plus(plus(minPerTx, contractHomeFee), ONE_PERCENT), "2");
        if (+send.amountSend < +minAmountPerTx) {
          return cb("Min amount per transaction is " + minAmountPerTx + " VLX");
        }
        if (+send.amountSend > +maxPerTx) {
          return cb("Max amount per transaction is " + maxPerTx + " VLX");
        }
      }
      /**
          * Swap into native */
      if (chosenNetwork.id === 'native') {
        console.log("Swap into native");
        $recipient = "";
        try {
          $recipient = bs58.decode(send.to);
          hex = $recipient.toString('hex');
        } catch (e$) {
          err = e$;
          return cb("Please enter valid address");
        }
        ethAddress = '0x' + hex;
        data = web3t.velas.EvmToNativeBridge.transferToNative.getData(ethAddress);
        store.current.send.contractAddress = web3t.velas.EvmToNativeBridge.address;
      }
      send.data = data;
      return cb(null);
    };
    beforeSendAnyway = function(){
      var cb;
      cb = console.log;
      return executeContractData(function(err){
        if (err != null) {
          store.current.send.error = err;
        }
        if (err != null) {
          return cb(err);
        }
        return sendMoney();
      });
    };
    sendAnyway = function(){
      return sendMoney();
    };
    toHex = function(it){
      return new BN(it);
    };
    cancel = function(event){
      navigate(store, web3t, 'wallets');
      return notifyFormResult(send.id, "Cancelled by user");
    };
    recipientChange = function(event){
      var _to;
      _to = event.target.value;
      send.to = _to;
      _to = _to.trim();
      resolveAddress({
        store: store,
        address: _to,
        coin: send.coin,
        network: send.network
      }, function(err){
        if (err != null) {
          return send.error = err;
        }
        return send.error = '';
      });
    };
    getValue = function(event){
      var value, ref$, ref1$, ref2$;
      value = (ref$ = event.target) != null ? ref$.value : void 8;
      if (!((ref1$ = event.target) != null && ref1$.value)) {
        return null;
      }
      if (((ref2$ = event.target) != null ? ref2$.value : void 8) === "") {
        return '0';
      }
      return value;
    };
    amountChange = function(event){
      var value;
      value = getValue(event);
      if (value == null || isNaN(value)) {
        value = "0";
      }
      return changeAmount(store, value, false, function(){});
    };
    performAmountEurChange = function(value){
      var toSend;
      toSend = calcCryptoFromEur(store, value);
      return changeAmount(store, toSend, false, function(){});
    };
    performAmountUsdChange = function(value){
      var toSend;
      toSend = calcCryptoFromUsd(store, value);
      return changeAmountCalcFiat(store, toSend, false, function(){});
    };
    amountEurChange = function(event){
      var value;
      value = getValue(event);
      send.amountSendEur = value;
      amountEurChange.timer = clearTimeout(amountEurChange.timer);
      return amountEurChange.timer = setTimeout(function(){
        return performAmountEurChange(value);
      }, 500);
    };
    amountUsdChange = function(event){
      var value, wallets, token, wallet, balance, usdRate;
      value = getValue(event);
      value = value != null ? value : 0;
      wallets = store.current.account.wallets;
      token = store.current.send.coin.token;
      wallet = find(function(it){
        return it.coin.token === token;
      })(
      wallets);
      balance = wallet.balance, usdRate = wallet.usdRate;
      send.amountSendUsd = value;
      amountUsdChange.timer = clearTimeout(amountUsdChange.timer);
      return amountUsdChange.timer = setTimeout(function(){
        return performAmountUsdChange(value);
      }, 500);
    };
    encodeDecode = function(){
      return send.showDataMode = (function(){
        switch (false) {
        case send.showDataMode !== 'decoded':
          return 'encoded';
        default:
          return 'decoded';
        }
      }());
    };
    showData = function(){
      switch (false) {
      case send.showDataMode !== 'decoded':
        return send.decodedData;
      default:
        return send.data;
      }
    };
    showLabel = function(){
      if (send.showDataMode === 'decoded') {
        return 'encoded';
      } else {
        return 'decoded';
      }
    };
    whenEmpty = function(str, def){
      if ((str != null ? str : "").length === 0) {
        return def;
      } else {
        return str;
      }
    };
    history = function(){
      store.current.sendMenuOpen = false;
      store.current.filter = {
        token: send.coin.token
      };
      applyTransactions(store);
      return navigate(store, web3t, 'history');
    };
    out$.network = network = (function(){
      switch (false) {
      case store.current.network !== 'testnet':
        return " (TESTNET) ";
      default:
        return "";
      }
    }());
    out$.invoice = invoice = function(wallet){
      var ref$, coin, network;
      store.current.sendMenuOpen = false;
      ref$ = store.current.send, coin = ref$.coin, network = ref$.network;
      importAll$(store.current.invoice, {
        coin: coin,
        wallet: wallet,
        network: network
      });
      return navigate(store, web3t, 'invoice');
    };
    out$.token = token = send.coin.token.toUpperCase();
    out$.name = name = (ref$ = send.coin.name) != null ? ref$ : token;
    feeToken = ((ref$ = wallet.network.txFeeIn) != null
      ? ref$
      : send.coin.token).toUpperCase();
    isData = ((ref$ = send.data) != null ? ref$ : "").length > 0;
    bridgeFeeToken = wallet.network.txBridgeFeeIn;
    chooseAuto = function(){
      if (hasSendError()) {
        return;
      }
      send.feeType = 'auto';
      return changeAmount(store, send.amountSend, false, function(){});
    };
    chooseCheap = function(){
      send.feeType = 'cheap';
      return changeAmount(store, send.amountSend, false, function(){});
    };
    chooseCustom = function(amount){
      var balance, amountSendFee, maxAmount;
      if (hasSendError()) {
        return;
      }
      balance = send.wallet.balance;
      amountSendFee = send.amountSendFee;
      send.feeType = 'custom';
      maxAmount = Math.max(1e8, balance);
      send.amountSendFee = send.feeCustomAmount = amount;
      return changeAmount(store, send.amountSend, false, function(){});
    };
    chosenCheap = send.feeType === 'cheap' ? 'chosen' : "";
    chosenAuto = send.feeType === 'auto' ? 'chosen' : "";
    chosenCustom = send.feeType === 'custom' ? 'chosen' : "";
    sendOptions = (ref$ = send.coin.txTypes) != null
      ? ref$
      : [];
    pending = wallet.pendingSent + ' ' + token;
    calcAmountAndFee = function(amountSend, trials, cb){
      var account;
      if (trials <= 0) {
        return cb("Cannot estimate max amount. Please try to type manually");
      }
      if (+amountSend === 0) {
        return cb("Balance is not enough to send tx");
      }
      account = {
        address: wallet.address,
        privateKey: wallet.privateKey
      };
      return calcFee({
        token: token,
        network: send.network,
        amount: amountSend,
        feeType: send.feeType,
        txType: send.txType,
        to: send.to,
        data: send.data,
        account: account
      }, function(err, amountSendFee){
        if (send.feeType === 'custom') {
          amountSendFee = send.amountSendFee;
        }
        if (err == null) {
          return cb(null, {
            amountSend: amountSend,
            amountSendFee: amountSendFee
          });
        }
        if (err != null && err !== "Balance is not enough to send tx") {
          return cb(err);
        }
        if (amountSendFee == null) {
          return cb("Fee cannot be calculated");
        }
        return cb(null);
      });
    };
    flag = false;
    useMax = function(cb){
      var minFee, amountSend, ref$, flag;
      minFee = send.wallet.network.txFeeOptions.cheap;
      amountSend = minus(wallet.balance, (ref$ = wallet.pendingSent) != null ? ref$ : 0);
      if (!flag) {
        amountSend = minus(amountSend, minFee);
      }
      if (amountSend < 0) {
        amountSend = 0;
      }
      flag = true;
      changeAmountSend(store, amountSend, false, function(){});
    };
    useMaxTryCatch = function(cb){
      var err;
      try {
        return useMax(cb);
      } catch (e$) {
        err = e$;
        return cb(err);
      }
    };
    out$.useMaxAmount = useMaxAmount = function(){
      return useMaxTryCatch(function(err){
        if (err != null) {
          return alert(err + "");
        }
      });
    };
    out$.hasSendError = hasSendError = function(){
      var error;
      error = store.current.send.error.toString();
      return error != null && error.length > 0 && error.toLowerCase() !== "not enough funds";
    };
    out$.changeAmount = changeAmount;
    out$.send = send;
    out$.wallet = wallet;
    out$.pending = pending;
    out$.feeToken = feeToken;
    out$.bridgeFeeToken = bridgeFeeToken;
    out$.primaryButtonStyle = primaryButtonStyle;
    out$.recipientChange = recipientChange;
    out$.amountChange = amountChange;
    out$.amountUsdChange = amountUsdChange;
    out$.amountEurChange = amountEurChange;
    out$.showData = showData;
    out$.showLabel = showLabel;
    out$.topup = topup(store);
    out$.history = history;
    out$.cancel = cancel;
    out$.sendAnyway = sendAnyway;
    out$.beforeSendAnyway = beforeSendAnyway;
    out$.chooseAuto = chooseAuto;
    out$.chooseCheap = chooseCheap;
    out$.chooseCustom = chooseCustom;
    out$.chosenAuto = chosenAuto;
    out$.chosenCheap = chosenCheap;
    out$.chosenCustom = chosenCustom;
    out$.defaultButtonStyle = defaultButtonStyle;
    out$.round5edit = round5edit;
    out$.round5 = round5;
    out$.sendOptions = sendOptions;
    out$.calcAmountAndFee = calcAmountAndFee;
    out$.isData = isData;
    out$.encodeDecode = encodeDecode;
    return out$;
  };
  function importAll$(obj, src){
    for (var key in src) obj[key] = src[key];
    return obj;
  }
  function import$(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
}).call(this);
