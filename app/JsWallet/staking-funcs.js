// Generated by LiveScript 1.6.0
(function(){
  var ref$, map, split, filter, find, foldl, drop, take, sum, unique, pairsToObj, div, times, plus, minus, roundHuman, SIMULATION_COUNT, EPOCHS_PER_YEAR, VALIDATOR_COUNT, asCallback, getStakesFromStakesAccounts, fillPools, loadValidatorsFromCache, queryPoolsWeb3t, queryPools, fillDelegators, fillDelegator, queryAccounts, queryAccountsWeb3t, fillAccounts, convertAccountsToViewModel, convertPoolsToViewModel, getValidatorsSkippedSlotsPercents, getFirstSlotInEpoch, getEpochSchedule, slice$ = [].slice, arrayFrom$ = Array.from || function(x){return slice$.call(x);};
  ref$ = require('prelude-ls'), map = ref$.map, split = ref$.split, filter = ref$.filter, find = ref$.find, foldl = ref$.foldl, drop = ref$.drop, take = ref$.take, sum = ref$.sum, unique = ref$.unique, pairsToObj = ref$.pairsToObj;
  ref$ = require('./math.js'), div = ref$.div, times = ref$.times, plus = ref$.plus, minus = ref$.minus;
  roundHuman = require('./round-human.js');
  SIMULATION_COUNT = 14600;
  EPOCHS_PER_YEAR = 1460;
  VALIDATOR_COUNT = 19;
  asCallback = function(p, cb){
    p['catch'](function(err){
      return cb(err);
    });
    return p.then(function(data){
      return cb(null, data);
    });
  };
  getStakesFromStakesAccounts = function(store, item){
    var found, stakes;
    found = filter(function(it){
      var stakeData, ref$, ref1$, ref2$, ref3$, ref4$;
      stakeData = it != null ? (ref$ = it.account) != null ? (ref1$ = ref$.data) != null ? (ref2$ = ref1$.parsed) != null ? (ref3$ = ref2$.info) != null ? (ref4$ = ref3$.stake) != null ? ref4$.delegation : void 8 : void 8 : void 8 : void 8 : void 8 : void 8;
      if (stakeData == null) {
        return false;
      }
      return +stakeData.activationEpoch < +stakeData.deactivationEpoch && (stakeData != null ? stakeData.voter : void 8) === item.key;
    })(
    store.staking.accounts);
    stakes = (function(){
      switch (false) {
      case !(found.length > 0):
        return map(function(it){
          var ref$, ref1$, ref2$, ref3$, ref4$, ref5$;
          return {
            seed: it.seed,
            item: it,
            stake: (ref$ = it.account) != null ? (ref1$ = ref$.data) != null ? (ref2$ = ref1$.parsed) != null ? (ref3$ = ref2$.info) != null ? (ref4$ = ref3$.stake) != null ? (ref5$ = ref4$.delegation) != null ? ref5$.stake : void 8 : void 8 : void 8 : void 8 : void 8 : void 8
          };
        })(
        found);
      default:
        return [];
      }
    }());
    return stakes;
  };
  fillPools = function(arg$, onFinish, arg1$){
    var store, web3t, onProgress, item, rest, ref$, stakes, onFinishLocal, onProgressLocal;
    store = arg$.store, web3t = arg$.web3t, onProgress = arg$.onProgress;
    item = arg1$[0], rest = slice$.call(arg1$, 1);
    if (item == null) {
      store.staking.allPoolsLoaded = true;
      store.staking.poolsAreLoading = false;
      return onFinish(null, []);
    }
    if (['validators', 'info', 'account_details', 'pool_details'].indexOf(store.current.page) === -1) {
      store.staking.allPoolsLoaded = false;
      store.staking.poolsAreLoading = false;
      return onFinish(null, []);
    }
    item.activatedStake = item.activatedStake;
    item.balanceRaw = item.activatedStake;
    item.address = item.key;
    item.stake = item.stake;
    item.stakeInitial = item.activatedStake;
    item.status = status;
    item.commission = item.commission;
    item.credits_observed = foldl(plus, 0)(
    map(function(it){
      return it[1];
    })(
    item.epochCredits));
    item.delegators = (ref$ = store.staking.delegators[item.votePubkey]) != null ? ref$ : 0;
    stakes = getStakesFromStakesAccounts(store, item);
    item.stakes = stakes;
    if (onProgress != null) {
      onProgress([item].concat(arrayFrom$(rest)));
    }
    onFinishLocal = function(err, pools){
      return onFinish(err, [item].concat(arrayFrom$(pools)));
    };
    onProgressLocal = function(pools){
      return onProgress([item].concat(arrayFrom$(pools)));
    };
    return fillPools({
      store: store,
      web3t: web3t,
      onProgress: onProgressLocal
    }, onFinishLocal, rest);
  };
  loadValidatorsFromCache = function(arg$, cb){
    var store, DEADLINE, lastTime, ref$, now, cacheResult;
    store = arg$.store;
    DEADLINE = 60000;
    lastTime = (ref$ = store.staking.lastTime) != null
      ? ref$
      : new Date().getTime();
    now = new Date().getTime();
    if (minus(now, lastTime) <= DEADLINE && store.staking.cachedValidators != null && store.staking.cachedValidators.length) {
      console.log("get validators from cache");
      cacheResult = store.staking.cachedValidators;
      return cb(null, cacheResult);
    }
    return asCallback(web3t.velas.NativeStaking.getStakingValidators(), function(err, validators){
      if (err != null) {
        console.error("GetStakingValidators err: ", err);
      }
      if (err != null) {
        return cb(null, []);
      }
      store.staking.cachedValidators = validators;
      store.staking.lastTime = new Date().getTime();
      return cb(null, validators);
    });
  };
  queryPoolsWeb3t = function(arg$, onFinish){
    var store, web3t, onProgress;
    store = arg$.store, web3t = arg$.web3t, onProgress = arg$.onProgress;
    return loadValidatorsFromCache({
      store: store
    }, function(err, validators){
      if (err != null) {
        return onFinish(err);
      }
      if (err != null) {
        validators = [];
      }
      store.staking.totalValidators = validators.length;
      store.staking.poolsAreLoading = true;
      return fillPools({
        store: store,
        web3t: web3t,
        onProgress: onProgress
      }, onFinish, validators);
    });
  };
  queryPools = function(arg$, onFinish){
    var store, web3t, onProgress;
    store = arg$.store, web3t = arg$.web3t, onProgress = arg$.onProgress;
    fillDelegators(store, web3t);
    return queryPoolsWeb3t({
      store: store,
      web3t: web3t,
      onProgress: onProgress
    }, function(err, pools){
      if (err != null) {
        return onFinish(err);
      }
      return onFinish(null, pools);
    });
  };
  fillDelegators = function(store, web3t){
    var accounts;
    accounts = store.staking.parsedProgramAccounts;
    return fillDelegator(store, web3t, accounts);
  };
  fillDelegator = function(store, web3t, arg$){
    var acc, accounts, voter, ref$, ref1$, ref2$, ref3$, ref4$, ref5$, activationEpoch, ref6$, ref7$, ref8$, ref9$, ref10$, ref11$, ref12$, deactivationEpoch, ref13$, ref14$, ref15$, ref16$, ref17$, ref18$;
    acc = arg$[0], accounts = slice$.call(arg$, 1);
    if (acc == null) {
      return;
    }
    voter = (ref$ = acc.account) != null ? (ref1$ = ref$.data) != null ? (ref2$ = ref1$.parsed) != null ? (ref3$ = ref2$.info) != null ? (ref4$ = ref3$.stake) != null ? (ref5$ = ref4$.delegation) != null ? ref5$.voter : void 8 : void 8 : void 8 : void 8 : void 8 : void 8;
    activationEpoch = Number((ref6$ = (ref7$ = acc.account) != null ? (ref8$ = ref7$.data) != null ? (ref9$ = ref8$.parsed) != null ? (ref10$ = ref9$.info) != null ? (ref11$ = ref10$.stake) != null ? (ref12$ = ref11$.delegation) != null ? ref12$.activationEpoch : void 8 : void 8 : void 8 : void 8 : void 8 : void 8) != null ? ref6$ : 0);
    deactivationEpoch = Number((ref6$ = (ref13$ = acc.account) != null ? (ref14$ = ref13$.data) != null ? (ref15$ = ref14$.parsed) != null ? (ref16$ = ref15$.info) != null ? (ref17$ = ref16$.stake) != null ? (ref18$ = ref17$.delegation) != null ? ref18$.deactivationEpoch : void 8 : void 8 : void 8 : void 8 : void 8 : void 8) != null ? ref6$ : 0);
    if (voter && (deactivationEpoch > activationEpoch || activationEpoch === web3t.velas.NativeStaking.max_epoch)) {
      store.staking.delegators[voter] = store.staking.delegators[voter] != null ? store.staking.delegators[voter] + 1 : 1;
    }
    fillDelegator(store, web3t, accounts);
  };
  queryAccounts = function(store, web3t, onProgress, onFinish){
    var accountIndex;
    accountIndex = store.current.accountIndex;
    if (store.staking.getAccountsFromCashe === true && store.staking.accountsCached[accountIndex] != null && store.staking.accountsCached[accountIndex].length > 0) {
      console.log("get accounts from cache");
      store.staking.allAccountsLoaded = true;
      store.staking.accountsAreLoading = false;
      return onFinish(null, store.staking.accountsCached[accountIndex]);
    }
    return queryAccountsWeb3t(store, web3t, onProgress, function(err, accounts){
      if (err != null) {
        return onFinish(err);
      }
      store.staking.accountsCached[accountIndex] = accounts;
      return onFinish(err, accounts);
    });
  };
  queryAccountsWeb3t = function(store, web3t, onProgress, onFinish){
    return asCallback(web3t.velas.NativeStaking.getParsedProgramAccounts(), function(err, parsedProgramAccounts){
      if (err != null) {
        parsedProgramAccounts = [];
      }
      store.staking.parsedProgramAccounts = parsedProgramAccounts;
      return asCallback(web3t.velas.NativeStaking.getOwnStakingAccounts(parsedProgramAccounts), function(err, accs){
        if (err != null) {
          accs = [];
        }
        store.staking.totalOwnStakingAccounts = accs.length;
        console.log("accs", accs);
        if (err != null) {
          return onFinish(err);
        }
        store.staking.accountsAreLoading = true;
        return fillAccounts({
          store: store,
          web3t: web3t,
          onProgress: onProgress,
          onFinish: onFinish
        }, accs);
      });
    });
  };
  fillAccounts = function(arg$, arg1$){
    var store, web3t, onProgress, onFinish, item, rest, rent, ref$, ref1$, ref2$, ref3$, ref4$;
    store = arg$.store, web3t = arg$.web3t, onProgress = arg$.onProgress, onFinish = arg$.onFinish;
    item = arg1$[0], rest = slice$.call(arg1$, 1);
    if (item == null) {
      store.staking.allAccountsLoaded = true;
      store.staking.accountsAreLoading = false;
      return onFinish(null, []);
    }
    if (['validators', 'info', 'account_details', 'pool_details'].indexOf(store.current.page) === -1) {
      store.staking.allAccountsLoaded = false;
      store.staking.accountsAreLoading = false;
      return onFinish(null, []);
    }
    store.staking.loadingAccountIndex += 1;
    rent = (ref$ = item.account) != null ? (ref1$ = ref$.data) != null ? (ref2$ = ref1$.parsed) != null ? (ref3$ = ref2$.info) != null ? (ref4$ = ref3$.meta) != null ? ref4$.rentExemptReserve : void 8 : void 8 : void 8 : void 8 : void 8;
    return asCallback(web3t.velas.NativeStaking.checkSeed(item.pubkey.toBase58()), function(err, seed){
      var ref$, ref1$, ref2$, ref3$, ref4$, ref5$, ref6$, ref7$, ref8$, activationEpoch, ref9$, ref10$, ref11$, ref12$, deactivationEpoch, ref13$, ref14$, ref15$, ref16$, ref17$, ref18$, ref19$, ref20$, ref21$, ref22$, onFinishLocal, onProgressLocal;
      item.seed = seed != null ? seed : "..";
      item.seedIndex = +(item.seed + "").split(":")[1];
      item.address = item.pubkey.toBase58();
      item.key = item.address;
      item.rentRaw = rent;
      item.balanceRaw = rent != null ? minus(item.account.lamports, rent) : '-';
      item.balance = rent != null ? div(times(Math.round(div(minus(item.account.lamports, rent), Math.pow(10, 9))), 100), 100) : "-";
      item.rent = rent != null ? div(rent, Math.pow(10, 9)) : "-";
      item.credits_observed = (ref$ = (ref1$ = item.account) != null ? (ref2$ = ref1$.data) != null ? (ref3$ = ref2$.parsed) != null ? (ref4$ = ref3$.info) != null ? (ref5$ = ref4$.stake) != null ? ref5$.creditsObserved : void 8 : void 8 : void 8 : void 8 : void 8) != null ? ref$ : 0;
      item.status = "inactive";
      item.validator = null;
      item.account = item.account;
      if ((ref$ = item.account) != null && ((ref6$ = ref$.data) != null && ((ref7$ = ref6$.parsed) != null && ((ref8$ = ref7$.info) != null && ref8$.stake)))) {
        activationEpoch = Number((ref9$ = item.account) != null ? (ref10$ = ref9$.data) != null ? (ref11$ = ref10$.parsed) != null ? (ref12$ = ref11$.info) != null ? ref12$.stake.delegation.activationEpoch : void 8 : void 8 : void 8 : void 8);
        deactivationEpoch = Number((ref13$ = item.account) != null ? (ref14$ = ref13$.data) != null ? (ref15$ = ref14$.parsed) != null ? (ref16$ = ref15$.info) != null ? ref16$.stake.delegation.deactivationEpoch : void 8 : void 8 : void 8 : void 8);
        if (deactivationEpoch > activationEpoch || activationEpoch === web3t.velas.NativeStaking.max_epoch) {
          item.status = "loading";
          item.validator = (ref17$ = item.account) != null ? (ref18$ = ref17$.data) != null ? (ref19$ = ref18$.parsed) != null ? (ref20$ = ref19$.info) != null ? (ref21$ = ref20$.stake) != null ? (ref22$ = ref21$.delegation) != null ? ref22$.voter : void 8 : void 8 : void 8 : void 8 : void 8 : void 8;
        }
      }
      if (onProgress != null) {
        onProgress([item].concat(arrayFrom$(rest)));
      }
      onFinishLocal = function(err, pools){
        return onFinish(err, [item].concat(arrayFrom$(pools)));
      };
      onProgressLocal = function(pools){
        return onProgress([item].concat(arrayFrom$(pools)));
      };
      return fillAccounts({
        store: store,
        web3t: web3t,
        onProgress: onProgressLocal,
        onFinish: onFinishLocal
      }, rest);
    });
  };
  convertAccountsToViewModel = function(accounts){
    return map(function(it){
      var ref$;
      return {
        account: it.account,
        address: (ref$ = it.key) != null ? ref$ : '..',
        key: it.key,
        balanceRaw: (ref$ = it.balanceRaw) != null ? ref$ : 0,
        balance: it.balance != null ? roundHuman(it.balance) : '..',
        rent: it.rent != null ? it.rent : "-",
        lastVote: (ref$ = it.lastVote) != null ? ref$ : '..',
        seed: (ref$ = it.seed) != null ? ref$ : '..',
        validator: (ref$ = it != null ? it.validator : void 8) != null ? ref$ : "",
        status: (ref$ = it.status) != null ? ref$ : "inactive",
        active_stake: typeof active_stake != 'undefined' && active_stake !== null
          ? active_stake
          : (ref$ = it != null ? it.active_stake : void 8) != null ? ref$ : 0,
        inactive_stake: typeof inactive_stake != 'undefined' && inactive_stake !== null
          ? inactive_stake
          : (ref$ = it != null ? it.inactive_stake : void 8) != null ? ref$ : 0,
        seedIndex: typeof seedIndex != 'undefined' && seedIndex !== null
          ? seedIndex
          : it.seedIndex,
        credits_observed: it.credits_observed
      };
    })(
    accounts);
  };
  convertPoolsToViewModel = function(pools){
    return map(function(it){
      var ref$;
      return {
        address: (ref$ = it.key) != null ? ref$ : '..',
        balanceRaw: it.activatedStake,
        checked: false,
        stake: it.stake != null ? it.stake : '..',
        stakeInitial: it.activatedStake != null ? parseFloat(div(it.activatedStake, Math.pow(10, 9))) : 0,
        commission: it.commission,
        lastVote: it.lastVote ? roundHuman(it.lastVote) : '..',
        stakers: it.delegators != null ? it.delegators : '..',
        isValidator: (ref$ = (it != null ? it.stakes : void 8) != null && it.stakes.length !== 0) != null ? ref$ : false,
        status: it.status,
        myStake: it != null && it.stakes
          ? it.stakes
          : [],
        credits_observed: it.credits_observed,
        nodePubkey: it.nodePubkey
      };
    })(
    pools);
  };
  /*
      * Calculate skipped solts percent for each validator.
      * @param   { Object } store - The mobx store object
      * @param   { Object } web3t - The web3t lib
      * @returns { Object } Object <pubKey, Number> where key is public node addess and value is percent of skipped slosts per current epoch.
      * */
  getValidatorsSkippedSlotsPercents = function(arg$, cb){
    var store, web3t;
    store = arg$.store, web3t = arg$.web3t;
    return asCallback(web3t.velas.NativeStaking.getCurrentEpochInfo(), function(err, epochInfo){
      var epoch, blockHeight, slotIndex, slotsInEpoch, transactionCount, absoluteSlot;
      if (err != null) {
        console.error(err);
      }
      epoch = epochInfo.epoch, blockHeight = epochInfo.blockHeight, slotIndex = epochInfo.slotIndex, slotsInEpoch = epochInfo.slotsInEpoch, transactionCount = epochInfo.transactionCount, absoluteSlot = epochInfo.absoluteSlot;
      store.staking.epochInfo = epochInfo;
      return asCallback(web3t.velas.NativeStaking.getLeaderSchedule(), function(err, result){
        console.log("getLeaderSchedule", result);
        store.staking.leaderSchedule = result;
        return getFirstSlotInEpoch(epoch, slotsInEpoch, function(err, first_slot_in_epoch){
          var start_slot, start_slot_index, last_slot_in_epoch, end_slot, end_slot_index, leader_per_slot_index, leader_slot_count, leader_skipped_slots, confirmed_blocks_index;
          console.log("first_slot_in_epoch = ", first_slot_in_epoch);
          start_slot = first_slot_in_epoch;
          start_slot_index = 0;
          last_slot_in_epoch = first_slot_in_epoch + slotsInEpoch - 1;
          end_slot = Math.min(absoluteSlot, last_slot_in_epoch);
          console.log("end_slot = ", end_slot);
          end_slot_index = end_slot - first_slot_in_epoch;
          leader_per_slot_index = {};
          each(function(it){
            var leader_slots, i$, len$, slot_index, results$ = [];
            leader_slots = store.staking.leaderSchedule[it];
            for (i$ = 0, len$ = leader_slots.length; i$ < len$; ++i$) {
              slot_index = leader_slots[i$];
              if (slot_index >= start_slot_index && slot_index <= end_slot_index) {
                results$.push(leader_per_slot_index[slot_index] = it);
              }
            }
            return results$;
          })(
          keys(
          store.staking.leaderSchedule));
          leader_slot_count = {};
          leader_skipped_slots = {};
          confirmed_blocks_index = 0;
          return asCallback(web3t.velas.NativeStaking.getConfirmedBlocks(start_slot, end_slot), function(err, result){
            var confirmedBlocks, ref$, total_slots, total_blocks_produced, scippedSlotsPercent;
            confirmedBlocks = (ref$ = result != null ? result.result : void 8) != null
              ? ref$
              : [];
            console.log("confirmedBlocks.length", confirmedBlocks.length);
            total_slots = end_slot_index - start_slot_index + 1;
            total_blocks_produced = confirmedBlocks.length;
            each(function(it){
              var slot_index, leader, slot, slot_of_next_confirmed_block, results$ = [];
              slot_index = it;
              leader = leader_per_slot_index[slot_index];
              slot = +start_slot + slot_index;
              if (leader_slot_count[leader + ""] == null) {
                leader_slot_count[leader + ""] = 0;
              }
              leader_slot_count[leader + ""] = +leader_slot_count[leader + ""] + 1;
              if (leader_skipped_slots[leader + ""] == null) {
                leader_skipped_slots[leader + ""] = 0;
              }
              while (true) {
                if (confirmed_blocks_index < confirmedBlocks.length) {
                  slot_of_next_confirmed_block = confirmedBlocks[confirmed_blocks_index];
                  if (slot_of_next_confirmed_block < slot) {
                    +(confirmed_blocks_index += 1);
                    continue;
                  }
                  if (slot_of_next_confirmed_block === slot) {
                    break;
                  }
                }
                leader_skipped_slots[leader + ""] = +leader_skipped_slots[leader + ""] + 1;
                break;
              }
              return results$;
            })(
            keys(
            leader_per_slot_index));
            console.log("leader_slot_count", Object.keys(leader_slot_count).length);
            console.log("leader_skipped_slots", Object.keys(leader_skipped_slots).length);
            scippedSlotsPercent = pairsToObj(
            map(function(it){
              var leader, leaderSlots, percent;
              leader = it;
              leaderSlots = leader_slot_count[leader];
              percent = times(div(store.staking.leaderSchedule[leader].length, end_slot), 100);
              return [leader, percent];
            })(
            keys(
            leader_slot_count)));
            return cb(null, scippedSlotsPercent);
          });
        });
      });
    });
  };
  /*
      * Get first slot in epoch.
      * @param   { Number } epoch - The epoch number for which the first slot is calculated
      * @param   { Number } slotsInEpoch - The total number of slots in epoch
      * @returns { Number } First slot in searched epoch. 
      * */
  getFirstSlotInEpoch = function(epoch, slotsInEpoch, cb){
    return getEpochSchedule(function(err, epochSchedule){
      var firstNormalEpoch, firstNormalSlot, leaderScheduleSlotOffset, slotsPerEpoch, warmup;
      firstNormalEpoch = epochSchedule.firstNormalEpoch, firstNormalSlot = epochSchedule.firstNormalSlot, leaderScheduleSlotOffset = epochSchedule.leaderScheduleSlotOffset, slotsPerEpoch = epochSchedule.slotsPerEpoch, warmup = epochSchedule.warmup;
      if (epoch <= firstNormalEpoch) {
        console.log("Epoch is less or equals to firstNormalEpoch");
        return cb(null, (Math.pow(2, epoch) - 1) * slotsInEpoch);
      }
      return cb(null, (epoch - firstNormalEpoch) * slotsPerEpoch + firstNormalSlot);
    });
  };
  /*
      * Get epoch schedule of current epoch.
      * @param   { Function } cb - The callback which will be executed after this function
      * @returns { Object } Epoch schedule {firstNormalEpoch, firstNormalSlot, leaderScheduleSlotOffset, slotsPerEpoch, warmup}
      * */
  getEpochSchedule = function(cb){
    return asCallback(web3t.velas.NativeStaking.getEpochSchedule(), function(err, epochSchedule){
      if (err != null) {
        console.error(err);
      }
      return cb(null, epochSchedule);
    });
  };
  module.exports = {
    queryPools: queryPools,
    queryAccounts: queryAccounts,
    convertAccountsToViewModel: convertAccountsToViewModel,
    convertPoolsToViewModel: convertPoolsToViewModel,
    getValidatorsSkippedSlotsPercents: getValidatorsSkippedSlotsPercents
  };
}).call(this);
