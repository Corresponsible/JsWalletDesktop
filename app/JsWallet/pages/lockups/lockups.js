// Generated by LiveScript 1.6.0
(function(){
  var react, reactDom, bignumber, getPrimaryInfo, getLang, historyFuncs, queryPools, icon, ref$, map, split, filter, find, foldl, sortBy, unique, head, each, div, times, plus, minus, hdkey, bip39, md5, Buffer, ethToVlx, roundHuman, requestStake, requestUnstake, txsHistory, poolsList, checkbox, icons, placeholder, canMakeStaking, alert, button, addressHolder, alertTxn, amountField, seedmem, moment, cb, getPair, toKeystore, showValidator, lockupsContent, lockups, stringify, fillLockupContract, fillLockupContracts, toString$ = {}.toString, slice$ = [].slice;
  react = require('react');
  reactDom = require('react-dom');
  bignumber = require('bignumber.js');
  getPrimaryInfo = require('../../get-primary-info.js');
  getLang = require('../../get-lang.js');
  historyFuncs = require('../../history-funcs.js');
  queryPools = require('../../stake-funcs.js').queryPools;
  icon = require('../icon.js');
  ref$ = require('prelude-ls'), map = ref$.map, split = ref$.split, filter = ref$.filter, find = ref$.find, foldl = ref$.foldl, sortBy = ref$.sortBy, unique = ref$.unique, head = ref$.head, each = ref$.each;
  ref$ = require('../../math.js'), div = ref$.div, times = ref$.times, plus = ref$.plus, minus = ref$.minus;
  ref$ = require('../../../web3t/providers/deps.js'), hdkey = ref$.hdkey, bip39 = ref$.bip39;
  md5 = require('md5');
  Buffer = require('safe-buffer').Buffer;
  ethToVlx = require('../../../web3t/addresses.js').ethToVlx;
  roundHuman = require('../../round-human.js');
  requestStake = require('./request-stake.js');
  requestUnstake = require('./request-unstake.js');
  txsHistory = require('./txs-history.js');
  poolsList = require('./pools-list.js');
  checkbox = require('../../components/checkbox.js');
  icons = require('../../icons.js');
  placeholder = require('../placeholder.js');
  canMakeStaking = require('../../staking/can-make-staking.js');
  alert = require('../confirmation.js').alert;
  button = require('../../components/button.js');
  addressHolder = require('../../components/address-holder.js');
  alertTxn = require('../alert-txn.js');
  amountField = require('../../components/amount-field.js');
  seedmem = require('../../seed.js');
  moment = require('moment');
  cb = console.log;
  getPair = function(wallet, path, index, password, withKeystore){
    var w, address, salt, iv, uuid, kdf, keystore;
    w = wallet.derivePath(path).deriveChild(index).getWallet();
    address = "0x" + w.getAddress().toString('hex');
    salt = Buffer.from('dc9e4a98886738bd8aae134a1f89aaa5a502c3fbd10e336136d4d5fe47448ad6', 'hex');
    iv = Buffer.from('cecacd85e9cb89788b5aab2f93361233', 'hex');
    uuid = Buffer.from('7e59dc028d42d09db29aa8a0f862cc81', 'hex');
    kdf = 'pbkdf2';
    keystore = (function(){
      switch (false) {
      case !withKeystore:
        return w.toV3String(password, {
          salt: salt,
          iv: iv,
          uuid: uuid,
          kdf: kdf
        });
      default:
        return "";
      }
    }());
    return {
      address: address,
      keystore: keystore
    };
  };
  toKeystore = function(store, withKeystore){
    var mnemonic, seed, wallet, index, password, staking, mining;
    mnemonic = seedmem.mnemonic;
    seed = bip39.mnemonicToSeed(mnemonic);
    wallet = hdkey.fromMasterSeed(seed);
    index = store.current.accountIndex;
    password = md5(wallet.derivePath("m1").deriveChild(index).getWallet().getAddress().toString('hex'));
    staking = (function(){
      switch (false) {
      case store.urlParams.anotheracc == null:
        return {
          address: window.toEthAddress(store.urlParams.anotheracc)
        };
      default:
        return getPair(wallet, 'm0', index, password, false);
      }
    }());
    mining = getPair(wallet, 'm0/2', index, password, withKeystore);
    return {
      staking: staking,
      mining: mining,
      password: password
    };
  };
  showValidator = function(store, web3t){
    return function(validator){
      return react.createElement('li', {}, ' ' + validator);
    };
  };
  lockupsContent = function(store, web3t){
    var style, lang, buttonPrimary3Style, goBack, pairs, activate, withdraw, topupTheContract, stakeToContract, changeAddress, changeWithdraw, changeStake, getOptions, useMin, useMax, voteForChange, vlxToken, hideStakePlace, build, cancel, refresh, iconStyle, stakerPoolStyle, stats, cancelChoosePool, children, currentContract, choosePoolFromList, lockupActionChoose, getBalance, yourBalance, langStake, changeUnstake, onChangeAutostaking, isForwardingEnabled, autostakingState, LockedPoolLabel, useMin2, useMax2, unstake;
    style = getPrimaryInfo(store);
    lang = getLang(store);
    buttonPrimary3Style = {
      border: "1px solid " + style.app.primary3,
      color: style.app.text2,
      background: style.app.primary3,
      backgroundColor: style.app.primary3Spare
    };
    if (store.lockups.lockupContracts.length === 0) {
      return;
    }
    goBack = historyFuncs(store, web3t).goBack;
    lang = getLang(store);
    pairs = store.staking.keystore;
    activate = function(step){
      return store.lockups.stake.step = step;
    };
    withdraw = function(){
      var ref$, address, lockedPool, maxWithdrawAllowed, lockupAddress, Timelock, contractAddress, amount, vlx2, vlxAddress, data, to;
      ref$ = store.lockups.chosenLockup, address = ref$.address, lockedPool = ref$.lockedPool, maxWithdrawAllowed = ref$.maxWithdrawAllowed;
      lockupAddress = store.lockups.chosenLockup.address;
      Timelock = web3t.velas.Timelock.at(lockupAddress);
      contractAddress = Timelock.address;
      amount = div(maxWithdrawAllowed.toFixed(), Math.pow(10, 18));
      if (+amount === 0) {
        return alert(store, lang.actionProhibited, cb);
      }
      vlx2 = find(function(it){
        return it.coin.token === 'vlx2';
      })(
      store.current.account.wallets);
      vlxAddress = vlx2.address2;
      data = Timelock.withdraw.getData(vlxAddress, amount);
      to = contractAddress;
      return web3t.vlx2.sendTransaction({
        to: to,
        data: data,
        amount: 0
      }, function(err){});
    };
    topupTheContract = function(){
      var type, stake, contractAddress, TimeLock, vlx2, vlxAddress;
      if (store.lockups.chosenLockup == null) {
        return alert(store, "please choose the contract", cb);
      }
      type = toString$.call(store.lockups.add.addValidatorStake).slice(8, -1);
      if (type !== 'String' && type !== 'Number') {
        return alert(store, "please enter correct amount, got " + type, cb);
      }
      stake = times(store.lockups.add.addValidatorStake, Math.pow(10, 18));
      contractAddress = store.lockups.chosenLockup.address;
      TimeLock = web3t.velas.Timelock.at(contractAddress);
      vlx2 = find(function(it){
        return it.coin.token === 'vlx2';
      })(
      store.current.account.wallets);
      vlxAddress = vlx2.address2;
      return TimeLock.getDefaultPool(function(err, lockedPool){
        var data, to, amount;
        if (err != null) {
          return cb(err);
        }
        data = TimeLock.stakeAmount.getData(vlxAddress, stake);
        to = TimeLock.address;
        amount = store.lockups.add.addValidatorStake;
        return web3t.vlx2.sendTransaction({
          to: to,
          amount: amount
        }, function(err){
          if (err != null) {
            return cb(err);
          }
          if (err != null) {
            return store.lockups.add.result = err + "";
          }
          return cb(null);
        });
      });
    };
    stakeToContract = function(){
      return canMakeStaking(store, web3t, function(err){
        var type, stake, contractAddress, TimeLock, vlx2, vlxAddress;
        if (err != null) {
          return alert(store, err, cb);
        }
        if (store.lockups.chosenLockup == null) {
          return alert(store, "please choose the contract", cb);
        }
        type = toString$.call(store.lockups.add.addValidatorStake).slice(8, -1);
        if (type !== 'String' && type !== 'Number') {
          return alert(store, "please enter correct amount, got " + type, cb);
        }
        stake = times(store.lockups.add.addValidatorStake, Math.pow(10, 18));
        contractAddress = store.lockups.chosenLockup.address;
        TimeLock = web3t.velas.Timelock.at(contractAddress);
        vlx2 = find(function(it){
          return it.coin.token === 'vlx2';
        })(
        store.current.account.wallets);
        vlxAddress = vlx2.address2;
        return TimeLock.getDefaultPool(function(err, lockedPool){
          var data, to, amount;
          if (err != null) {
            return cb(err);
          }
          data = TimeLock.stake.getData(vlxAddress, stake);
          to = TimeLock.address;
          amount = store.lockups.add.addValidatorStake;
          return web3t.vlx2.sendTransaction({
            to: to,
            data: data,
            amount: amount
          }, function(err){
            if (err != null) {
              return cb(err);
            }
            if (err != null) {
              return store.lockups.add.result = err + "";
            }
          });
        });
      });
    };
    changeAddress = function(it){
      return store.staking.add.addValidator = it.target.value;
    };
    changeWithdraw = function(it){
      return store.lockups.withdrawAmount = it.target.value;
    };
    changeStake = function(it){
      var value, err;
      try {
        value = new bignumber(it.target.value).toFixed().toString();
        store.lockups.add.addValidatorStake = value;
      } catch (e$) {
        err = e$;
        console.log("[Change-stake]: " + err);
      }
    };
    if (pairs.mining == null) {
      return null;
    }
    getOptions = function(cb){
      return web3t.velas.Staking.candidateMinStake(function(err, data){
        var min, balance, stake, max;
        if (err != null) {
          return cb(err);
        }
        min = (function(){
          switch (false) {
          case !(+store.lockups.stakeAmountTotal >= 10000):
            return 1;
          default:
            return div(data, Math.pow(10, 18));
          }
        }());
        balance = minus(div(store.lockups.chosenLockup.lockedFundsRaw, Math.pow(10, 18)), 0.1);
        stake = store.lockups.add.addValidatorStake;
        if (10000 > +stake) {
          return cb(lang.amountLessStaking);
        }
        if (+balance < +stake) {
          return cb(lang.balanceLessStaking);
        }
        max = +balance;
        return cb(null, {
          min: min,
          max: max
        });
      });
    };
    useMin = function(){
      return store.lockups.add.addValidatorStake = 10000;
    };
    useMax = function(){
      var balance;
      balance = div(store.lockups.chosenLockup.lockedFundsRaw, Math.pow(10, 18));
      return store.lockups.add.addValidatorStake = Math.max(minus(balance, 0.1), 0);
    };
    voteForChange = function(){
      return web3t.velas.ValidatorSet.emitInitiateChangeCallable(function(err, can){
        var data, to, amount;
        if (err != null) {
          return alert(store, err, cb);
        }
        if (can !== true) {
          return alert(store, lang.actionProhibited, cb);
        }
        data = web3t.velas.ValidatorSet.emitInitiateChange.getData();
        to = web3t.velas.ValidatorSet.address;
        amount = 0;
        return web3t.vlx2.sendTransaction({
          to: to,
          data: data,
          amount: amount
        }, function(err){
          return store.current.page = 'staking';
        });
      });
    };
    vlxToken = "VLX";
    hideStakePlace = function(){
      store.lockups.lockupStakingAddress = null;
      return null;
    };
    build = function(store, web3t){
      return function(item){
        var address, lockedFunds, lockedPool, stake, lockedFundsReleaseTime, lockThreshold, index, vlx2, wallet, choose, showStakePlace, lockedUntil, lockedThreshold, children;
        address = item.address, lockedFunds = item.lockedFunds, lockedPool = item.lockedPool, stake = item.stake, lockedFundsReleaseTime = item.lockedFundsReleaseTime, lockThreshold = item.lockThreshold;
        stake = roundHuman(parseFloat(div(item.stake, Math.pow(10, 18))));
        index = store.lockups.lockupContracts.indexOf(item) + 1;
        vlx2 = find(function(it){
          return it.coin.token === 'vlx2';
        })(
        store.current.account.wallets);
        wallet = {
          address: ethToVlx(item.address),
          network: vlx2.network,
          coin: vlx2.coin
        };
        choose = function(){
          var cb, lockedPool, contract;
          cb = console.log;
          item.checked = true;
          store.lockups.error = "";
          lockedPool = item.lockedPool;
          contract = item.address;
          store.lockups.currentTimelock = web3t.velas.Timelock.at(contract);
          return web3t.velas.Staking.stakeAmount(lockedPool, contract, function(err, amount){
            store.lockups.stakeAmountTotal = amount.toFixed();
            store.lockups.chosenLockup = item;
            return poolsList.init({
              store: store,
              web3t: web3t
            }, function(err){
              return requestUnstake.init({
                store: store,
                web3t: web3t
              }, function(err){
                if (err != null) {
                  return cb(err);
                }
                return cb(null);
              });
            });
          });
        };
        showStakePlace = function(){
          store.lockups.lockupStakingAddress = lockedPool;
          return null;
        };
        lockedUntil = lockedFundsReleaseTime != null ? moment(lockedFundsReleaseTime * 1000).format("DD/MM/YYYY hh:mm") : "..";
        lockedThreshold = lockThreshold != null ? div(lockThreshold, Math.pow(10, 18)) : "..";
        return react.createElement('tr', {
          key: item.address + "",
          onMouseEnter: showStakePlace,
          onMouseLeave: hideStakePlace,
          className: item.status + ""
        }, children = [
          react.createElement('td', {}, children = react.createElement('span', {
            className: item.status + " circle"
          }, ' ' + index)), react.createElement('td', {
            datacolumn: 'Staker Address',
            title: ethToVlx(item.address) + ""
          }, children = addressHolder({
            store: store,
            wallet: wallet
          })), react.createElement('td', {}, ' ' + lockedFunds), react.createElement('td', {}, ' ' + stake + ' '), react.createElement('td', {}, ' ' + lockedThreshold + '    '), react.createElement('td', {}, ' ' + lockedUntil + '           '), react.createElement('td', {}, children = button({
            store: store,
            onClick: choose,
            type: 'secondary',
            icon: 'arrowRight'
          }))
        ]);
      };
    };
    cancel = function(){
      store.lockups.chosenLockup = null;
      return store.lockups.add.addValidatorStake = 0;
    };
    refresh = function(){
      var cb;
      store.staking.allPoolsLoaded = false;
      if ((store.staking.allPoolsLoaded === false || store.staking.allPoolsLoaded == null) && store.staking.poolsAreLoading === true) {
        return false;
      }
      store.staking.poolsAreLoading = true;
      cb = console.log;
      return cb(null, 'done');
    };
    iconStyle = {
      color: style.app.loader,
      marginTop: "10px",
      width: "inherit"
    };
    stakerPoolStyle = {
      maxWidth: 200,
      background: style.app.stats
    };
    stats = {
      background: style.app.stats
    };
    cancelChoosePool = function(){
      return poolsList.init({
        store: store,
        web3t: web3t,
        selectAction: false
      }, function(){});
    };
    return react.createElement('div', {
      className: 'staking-content delegate'
    }, children = [
      store.staking.chosenPool == null && store.lockups.chosenLockup == null ? react.createElement('div', {
        className: 'main-sections'
      }, children = react.createElement('div', {
        id: "lockups",
        className: 'form-group'
      }, children = react.createElement('div', {
        className: 'section'
      }, children = [
        react.createElement('div', {
          className: 'title'
        }, children = react.createElement('h3', {}, ' Lock-up contracts')), react.createElement('div', {
          onMouseLeave: hideStakePlace,
          className: 'description table-scroll lockup'
        }, children = react.createElement('table', {}, children = [
          react.createElement('thead', {}, children = react.createElement('tr', {}, children = [
            react.createElement('td', {
              width: "3%",
              style: stats
            }, ' #'), react.createElement('td', {
              width: "40%",
              style: stakerPoolStyle
            }, ' Address'), react.createElement('td', {
              width: "20%",
              style: stats
            }, ' Non-staked Amount'), react.createElement('td', {
              width: "20%",
              style: stats
            }, ' Staked Amount'), react.createElement('td', {
              width: "7%",
              style: stats
            }, ' Threshold, VLX'), react.createElement('td', {
              width: "10%",
              style: stats
            }, ' Locked Until'), react.createElement('td', {
              width: "9%",
              style: stats
            }, ' Select')
          ])), react.createElement('tbody', {}, children = map(build(store, web3t))(
          store.lockups.lockupContracts))
        ]))
      ]))) : void 8, store.lockups.chosenLockup != null ? (currentContract = store.lockups.chosenLockup, choosePoolFromList = function(){
        return store.lockups.chosenLockupAction = 'select';
      }, lockupActionChoose = currentContract.lockedPool == null || (currentContract.lockedPool != null && +currentContract.lockedPool === 0), getBalance = function(){
        var wallet;
        wallet = find(function(it){
          return it.coin.token === 'vlx2';
        })(
        store.current.account.wallets);
        return wallet.balance;
      }, yourBalance = " " + roundHuman(getBalance()) + " ", langStake = store.lockups.stakeAmountTotal > 0
        ? lang.stakeMore
        : lang.stake, changeUnstake = function(it){
        return store.lockups.unstakeAmount = it.target.value;
      }, onChangeAutostaking = function(it){
        var cb, value, contractAddress, TimeLock, func, data, to;
        cb = console.log;
        value = it.target.value === 'true';
        contractAddress = store.lockups.chosenLockup.address;
        TimeLock = web3t.velas.Timelock.at(contractAddress);
        func = store.lockups.chosenLockup.isForwardingEnabled
          ? TimeLock.disableForwarding
          : TimeLock.enableForwarding;
        data = func.getData();
        to = contractAddress;
        return web3t.vlx2.sendTransaction({
          to: to,
          data: data,
          amount: 0
        }, function(err){
          if (err != null) {
            return cb(err);
          }
        });
      }, isForwardingEnabled = store.lockups.chosenLockup.isForwardingEnabled === true, autostakingState = isForwardingEnabled ? "enabled" : "disabled", LockedPoolLabel = store.lockups.chosenLockupAction === 'select' ? "Select default pool from the list:" : "Default pool:", react.createElement('div', {
        id: "choosen-lockup",
        className: 'single-section form-group single-section45016658'
      }, children = [
        react.createElement('div', {
          className: 'section'
        }, children = [
          react.createElement('div', {
            className: 'title'
          }, children = [
            react.createElement('h3', {}, ' Lock-up contract'), react.createElement('div', {
              className: 'buttons'
            }, children = button({
              store: store,
              onClick: cancel,
              type: 'secondary',
              icon: "back",
              text: "Back",
              id: typeof id != 'undefined' && id !== null ? id : "cancel-pool"
            }))
          ]), react.createElement('div', {
            className: 'description'
          }, children = react.createElement('div', {
            title: store.lockups.chosenLockup.address + "",
            className: 'chosen-pool'
          }, children = [
            react.createElement('span', {}, children = [
              " " + ethToVlx(store.lockups.chosenLockup.address), react.createElement('img', {
                src: icons.imgCheck + "",
                className: 'check'
              })
            ]), react.createElement('div', {
              className: 'settings'
            }, children = [
              currentContract.lockedPool != null && +currentContract.lockedPool !== 0 ? react.createElement('div', {
                className: 'flex-container flex-container-centered settings-item'
              }, children = [
                checkbox({
                  store: store,
                  value: isForwardingEnabled,
                  id: "autostaking-switcher",
                  onChange: onChangeAutostaking,
                  checked: isForwardingEnabled
                }), react.createElement('span', {}, ' Autostaking is ' + autostakingState)
              ]) : void 8, react.createElement('div', {
                className: 'flex-container flex-container-centered settings-item'
              }, children = [
                currentContract.lockedPool != null ? store.lockups.chosenLockupAction === 'select' ? button({
                  store: store,
                  onClick: cancelChoosePool,
                  text: "Cancel",
                  noIcon: true,
                  id: typeof id != 'undefined' && id !== null ? id : "cancel-choose-pool"
                }) : void 8 : void 8, react.createElement('div', {
                  className: 'subtitle color'
                }, children = react.createElement('label', {}, ' ' + LockedPoolLabel)), react.createElement('div', {
                  className: 'table-non-scroll min-height description width100'
                }, children = poolsList({
                  store: store,
                  web3t: web3t
                })), store.lockups.chosenLockupAction === 'choose' ? react.createElement('div', {}, children = button({
                  store: store,
                  classes: "width-auto",
                  text: "Select default pool",
                  noIcon: true,
                  onClick: choosePoolFromList,
                  style: {
                    width: 'auto'
                  }
                })) : void 8
              ])
            ])
          ]))
        ]), react.createElement('div', {
          className: 'section'
        }, children = [
          react.createElement('div', {
            className: 'title'
          }, children = react.createElement('h3', {}, ' ' + lang.withdraw)), react.createElement('div', {
            className: 'description'
          }, children = store.lockups.chosenLockup.maxWithdrawAllowed > 0
            ? react.createElement('div', {
              className: 'left'
            }, children = [
              react.createElement('label', {}), react.createElement('div', {
                className: 'balance'
              }), button({
                store: store,
                onClick: withdraw,
                classes: "width-auto",
                type: 'secondary',
                icon: 'apply',
                text: "Withdraw " + div(store.lockups.chosenLockup.maxWithdrawAllowed, Math.pow(10, 18)) + " VLX"
              })
            ])
            : react.createElement('div', {
              className: 'balance'
            }, children = [
              react.createElement('span', {}, ' You have no available '), react.createElement('span', {
                className: 'color'
              }, ' VLX '), react.createElement('span', {}, ' to withdraw')
            ]))
        ]), requestStake(store, web3t), requestUnstake(store, web3t), false && +store.lockups.stakeAmountTotal > 0 ? (useMin2 = function(){
          return store.lockups.unstakeAmount = 0;
        }, useMax2 = function(){
          var balance;
          balance = div(store.lockups.chosenLockup.stake, Math.pow(10, 18));
          return store.lockups.unstakeAmount = balance;
        }, unstake = function(){
          var ref$, address, lockedPool, lockupAddress, Timelock, contractAddress, poolAddress, amount, vlx2, vlxAddress, data, to;
          ref$ = store.lockups.chosenLockup, address = ref$.address, lockedPool = ref$.lockedPool;
          lockupAddress = store.lockups.chosenLockup.address;
          Timelock = web3t.velas.Timelock.at(lockupAddress);
          contractAddress = Timelock.address;
          poolAddress = lockedPool;
          amount = times(store.lockups.unstakeAmount, Math.pow(10, 18));
          if (+amount > +store.lockups.stakeAmountTotal) {
            return alert(store, lang.max + " " + div(max.toFixed(), Math.pow(10, 18)));
          }
          if (+amount === 0) {
            return alert(store, lang.actionProhibited, cb);
          }
          vlx2 = find(function(it){
            return it.coin.token === 'vlx2';
          })(
          store.current.account.wallets);
          vlxAddress = vlx2.address2;
          data = Timelock.unstake.getData(vlxAddress, amount);
          to = poolAddress;
          return web3t.vlx2.sendTransaction({
            to: to,
            data: data,
            amount: 0,
            gas: 4600000,
            gasPrice: 1000000
          }, function(err){
            if (err != null) {
              return cb(err);
            }
          });
        }, react.createElement('div', {
          className: 'section'
        }, children = [
          react.createElement('div', {
            className: 'title'
          }, children = react.createElement('h3', {}, ' Unstake')), react.createElement('div', {
            className: 'description'
          }, children = react.createElement('div', {
            className: 'left'
          }, children = [
            react.createElement('label', {}, ' Unstake'), amountField({
              store: store,
              value: store.lockups.unstakeAmount,
              onChange: changeUnstake,
              placeholder: lang.unstake,
              token: "vlx2",
              id: "unstake-vlx-input"
            }), react.createElement('div', {
              className: 'balance'
            }, children = [
              react.createElement('span', {
                className: 'small-btns'
              }, children = [
                react.createElement('button', {
                  style: buttonPrimary3Style,
                  onClick: useMin2,
                  className: 'small'
                }, ' ' + lang.min), react.createElement('button', {
                  style: buttonPrimary3Style,
                  onClick: useMax2,
                  className: 'small'
                }, ' ' + lang.max)
              ]), react.createElement('span', {}, ' ' + lang.stake + ':'), react.createElement('span', {
                className: 'color'
              }, ' ' + roundHuman(div(store.lockups.chosenLockup.stake, Math.pow(10, 18)))), react.createElement('img', {
                src: icons.vlxIcon + "",
                className: 'label-coin'
              }), react.createElement('span', {
                className: 'color'
              }, ' ' + vlxToken)
            ]), button({
              store: store,
              onClick: unstake,
              type: 'secondary',
              icon: 'apply',
              text: 'btnApply'
            })
          ]))
        ])) : void 8
      ])) : void 8
    ]);
  };
  lockups = function(arg$){
    var store, web3t, children;
    store = arg$.store, web3t = arg$.web3t;
    return react.createElement('div', {
      className: 'lockups-content'
    }, children = lockupsContent(store, web3t));
  };
  stringify = function(value){
    if (value != null) {
      return roundHuman(parseFloat(div(value, Math.pow(10, 18))));
    } else {
      return '..';
    }
  };
  fillLockupContract = function(arg$, arg1$, cb){
    var web3t, store, contract, contracts, item, TimeLock;
    web3t = arg$.web3t, store = arg$.store;
    contract = arg1$[0], contracts = slice$.call(arg1$, 1);
    if (contract == null) {
      return cb(null, []);
    }
    item = {};
    TimeLock = web3t.velas.Timelock.at(contract);
    return TimeLock.getNonStakedFunds(function(err, lockedFunds){
      if (err != null) {
        return cb(err);
      }
      item.address = contract;
      item.lockedFundsRaw = lockedFunds;
      item.lockedFunds = +lockedFunds !== 0 ? roundHuman(parseFloat(div(lockedFunds, Math.pow(10, 18)))) : 0;
      item.status = 'inactive';
      return TimeLock.getDefaultPool(function(err, lockedPool){
        if (err != null) {
          return cb(err);
        }
        item.lockedPool = lockedPool;
        return web3t.velas.Staking.stakeAmount(lockedPool, contract, function(err, amount){
          var ref$;
          if (err != null) {
            return cb(err);
          }
          store.lockups.lockupStaking[lockedPool] = (ref$ = store.lockups.lockupStaking[lockedPool]) != null
            ? ref$
            : [];
          store.lockups.lockupStaking[lockedPool].push(amount);
          item.stake = amount;
          return TimeLock.getLockedFundsReleaseTime(function(err, lockedFundsReleaseTime){
            if (err != null) {
              return cb(err);
            }
            item.lockedFundsReleaseTime = lockedFundsReleaseTime;
            return TimeLock.isForwardingEnabled(function(err, isForwardingEnabled){
              if (err != null) {
                return cb(err);
              }
              item.isForwardingEnabled = isForwardingEnabled;
              return TimeLock.maxWithdrawAllowed(function(err, max){
                if (err != null) {
                  return cb(err);
                }
                item.maxWithdrawAllowed = max;
                return TimeLock.getLockThreshold(function(err, lockThreshold){
                  var _item;
                  if (err != null) {
                    console.error("err:", err);
                  }
                  item.lockThreshold = lockThreshold;
                  _item = [item];
                  return fillLockupContract({
                    web3t: web3t,
                    store: store
                  }, contracts, function(err, rest){
                    var all;
                    all = _item.concat(rest);
                    return cb(null, all);
                  });
                });
              });
            });
          });
        });
      });
    });
  };
  fillLockupContracts = function(arg$, contracts, cb){
    var web3t, store;
    web3t = arg$.web3t, store = arg$.store;
    return fillLockupContract({
      web3t: web3t,
      store: store
    }, contracts, function(err, res){
      if (err != null) {
        return cb(err);
      }
      return cb(null, res);
    });
  };
  lockups.fillLockupContracts = fillLockupContracts;
  lockups.init = function(arg$, cb){
    var store, web3t, vlx2;
    store = arg$.store, web3t = arg$.web3t;
    store.lockups.stake.step = "topup";
    store.lockups.stake.choosenPull = null;
    store.lockups.currentTimelock = null;
    store.lockups.chosenLockupAction = '';
    store.lockups.withdrawAmount = 0;
    store.lockups.unstakeAmount = 0;
    store.lockups.add.addValidatorStake = 0;
    store.lockups.add.addTopupStake = 0;
    store.lockups.lockupWasChoosed = false;
    store.staking.poolWasChoosed = false;
    store.lockups.chosenLockup = null;
    vlx2 = find(function(it){
      return it.coin.token === 'vlx2';
    })(
    store.current.account.wallets);
    return web3t.velas.Resolver.getLockups(vlx2.address2, function(err, lockups){
      if (err != null) {
        return cb(err);
      }
      store.lockups.lockupStaking = {};
      return fillLockupContracts({
        web3t: web3t,
        store: store
      }, lockups, function(err, result){
        store.lockups.lockupContracts = result;
        return cb(null);
      });
    });
  };
  module.exports = lockups;
}).call(this);
