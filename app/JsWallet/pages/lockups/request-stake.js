// Generated by LiveScript 1.6.0
(function(){
  var react, reactDom, bignumber, navigate, getPrimaryInfo, web3, getLang, icons, ref$, ethToVlx, vlxToEth, div, times, plus, minus, map, split, filter, find, foldl, sortBy, unique, head, each, canMakeStaking, amountField, checkbox, addressHolder, alertTxn, button, alert, roundHuman, seedmem, moment, lockups, cb, stringify, orderWithdrawProcess, notAvailableRightNow, toString$ = {}.toString;
  react = require('react');
  reactDom = require('react-dom');
  bignumber = require('bignumber.js');
  navigate = require('../../navigate.js');
  getPrimaryInfo = require('../../get-primary-info.js');
  web3 = require('../../web3.js');
  getLang = require('../../get-lang.js');
  icons = require('../../icons.js');
  ref$ = require('../../../web3t/addresses.js'), ethToVlx = ref$.ethToVlx, vlxToEth = ref$.vlxToEth;
  ref$ = require('../../math.js'), div = ref$.div, times = ref$.times, plus = ref$.plus, minus = ref$.minus;
  ref$ = require('prelude-ls'), map = ref$.map, split = ref$.split, filter = ref$.filter, find = ref$.find, foldl = ref$.foldl, sortBy = ref$.sortBy, unique = ref$.unique, head = ref$.head, each = ref$.each;
  canMakeStaking = require('../../staking/can-make-staking.js');
  amountField = require('../../components/amount-field.js');
  checkbox = require('../../components/checkbox.js');
  addressHolder = require('../../components/address-holder.js');
  alertTxn = require('../alert-txn.js');
  button = require('../../components/button.js');
  alert = require('../confirmation.js').alert;
  roundHuman = require('../../round-human.js');
  seedmem = require('../../seed.js');
  moment = require('moment');
  lockups = require('./lockups.js');
  cb = bind$(console, 'log');
  stringify = function(value){
    if (value != null) {
      return roundHuman(parseFloat(div(value, Math.pow(10, 18))));
    } else {
      return '..';
    }
  };
  orderWithdrawProcess = function(store, web3t){
    var style, stakerPoolStyle, stats, buttonPrimary3Style, getBalance, yourBalance, vlxToken, currentContract, lockedFunds, lockedFundsRaw, lang, currentStep, activate, activateFirst, activateSecond, activateThird, activeClass, activeFirst, activeSecond, activeThird, currentContractHasDefaultPool, buildPool, isEnoughToStake, topupTheContract, stakeLockedToContract, stakeToContract, isForwardingEnabled, stakeFunc, changeStake, useMin, useMax, epochNext, ref$, children, useMinTopup, useMaxTopup, changeTopup;
    style = getPrimaryInfo(store);
    stakerPoolStyle = {
      maxWidth: 200,
      background: style.app.stats
    };
    stats = {
      background: style.app.stats
    };
    buttonPrimary3Style = {
      border: "1px solid " + style.app.primary3,
      color: style.app.text2,
      background: style.app.primary3,
      backgroundColor: style.app.primary3Spare
    };
    getBalance = function(){
      var wallet;
      wallet = find(function(it){
        return it.coin.token === 'vlx2';
      })(
      store.current.account.wallets);
      return wallet.balance;
    };
    yourBalance = " " + roundHuman(getBalance()) + " ";
    vlxToken = "VLX";
    currentContract = store.lockups.chosenLockup;
    lockedFunds = currentContract.lockedFunds;
    lockedFundsRaw = parseFloat(div(currentContract.lockedFundsRaw, Math.pow(10, 18)));
    lang = getLang(store);
    currentStep = store.lockups.stake.step;
    activate = function(step){
      return function(){
        if (step === 'stake') {
          if (!currentContractHasDefaultPool) {
            return;
          }
        }
        return store.lockups.stake.step = step;
      };
    };
    if (lockedFundsRaw > 0) {
      activate('choose-pool');
    }
    if (store.lockups.stake.choosenPull != null) {
      activate('stake');
    }
    activateFirst = activate('topup');
    activateSecond = activate('choose-pool');
    activateThird = activate('stake');
    activeClass = function(step){
      if (currentStep === step) {
        return 'active';
      } else {
        return '';
      }
    };
    activeFirst = activeClass('topup');
    activeSecond = activeClass('choose-pool');
    activeThird = activeClass('stake');
    currentContractHasDefaultPool = currentContract.lockedPool != null && +currentContract.lockedPool !== 0;
    buildPool = function(store, web3t){
      return function(item){
        var checked, stake, myStake, lockupStaking, extraStake, index, choosePull, toEth, reward, filled, filledColor, vlx2, wallet, votePower, mystakeClass, pointerClass, children;
        checked = item.checked;
        stake = item.stake;
        myStake = (function(){
          switch (false) {
          case +item.myStake !== 0:
            return item.withdrawAmount;
          default:
            return item.myStake;
          }
        }());
        if (myStake == null) {
          myStake = 0;
        }
        lockupStaking = store.lockups.lockupStaking[item.address];
        if (myStake != null && lockupStaking != null && lockupStaking.length > 0) {
          extraStake = foldl(plus, 0)(
          lockupStaking);
          myStake = plus(extraStake, myStake);
        }
        index = store.staking.pools.indexOf(item) + 1;
        choosePull = function(){
          var cb, lockupAddress, Timelock, contractAddress, data, to, currentContract;
          cb = function(err, data){
            if (err != null) {
              return alert(store, err, bind$(console, 'log'));
            }
          };
          store.lockups.successCb = function(){
            store.current.page = 'choosestaker';
            return store.lockups.chosenLockup = currentContract;
          };
          store.lockups.error = "";
          lockupAddress = store.lockups.chosenLockup.address;
          Timelock = web3t.velas.Timelock.at(lockupAddress);
          contractAddress = Timelock.address;
          data = Timelock.changeDefaultPool.getData(item.address);
          to = contractAddress;
          currentContract = store.lockups.chosenLockup;
          return web3t.vlx2.sendTransaction({
            to: to,
            data: data,
            amount: 0
          }, function(err){
            if (store.lockups.successCb != null) {
              return store.lockups.successCb();
            }
          });
        };
        toEth = function(){
          return item.eth = !item.eth;
        };
        reward = (function(){
          switch (false) {
          case item.validatorRewardPercent !== "..":
            return "..";
          default:
            return (100 - +item.validatorRewardPercent) * 1.4285714286;
          }
        }());
        filled = roundHuman(reward) + "%";
        filledColor = {
          color: (function(){
            switch (false) {
            case !(reward > 95):
              return 'red';
            case !(reward > 75):
              return 'orange';
            case !(reward > 40):
              return "rgb(165, 174, 81)";
            default:
              return "rgb(38, 219, 85)";
            }
          }())
        };
        vlx2 = find(function(it){
          return it.coin.token === 'vlx2';
        })(
        store.current.account.wallets);
        wallet = {
          address: ethToVlx(item.address),
          network: vlx2.network,
          coin: vlx2.coin
        };
        votePower = (function(){
          switch (false) {
          case item.votePower == null:
            return item.votePower + "%";
          default:
            return "...";
          }
        }());
        mystakeClass = +myStake > 0 ? "with-stake" : "";
        pointerClass = store.lockups.lockupStakingAddress != null && store.lockups.lockupStakingAddress === item.address ? "stake-pointer" : "";
        return react.createElement('tr', {
          className: item.status + " " + pointerClass
        }, children = [
          react.createElement('td', {}, children = react.createElement('span', {
            className: item.status + " circle"
          }, ' ' + index)), react.createElement('td', {
            datacolumn: 'Staker Address',
            title: ethToVlx(item.address) + ""
          }, children = addressHolder({
            store: store,
            wallet: wallet
          })), react.createElement('td', {}, ' ' + stake), react.createElement('td', {
            className: mystakeClass + ""
          }, ' ' + stringify(myStake)), react.createElement('td', {}, children = button({
            classes: "choose-pool",
            store: store,
            onClick: choosePull,
            type: 'secondary',
            icon: 'arrowRight'
          }))
        ]);
      };
    };
    isEnoughToStake = function(stake, balance, cb){
      var minAmountStake, total, min, max;
      stake = +stake;
      balance = +balance;
      minAmountStake = 10000;
      if (stake > balance) {
        return cb("Staking amount more than Locked amount");
      }
      total = plus(div(store.lockups.stakeAmountTotal, Math.pow(10, 18)), store.staking.stakeAmountTotal);
      if (total >= minAmountStake) {
        return cb(null);
      }
      min = (function(){
        switch (false) {
        case !(+total >= 10000):
          return 1;
        default:
          return minAmountStake;
        }
      }());
      balance = minus(balance, 0.1);
      if (10000 > +stake) {
        return cb(lang.amountLessStaking);
      }
      if (+balance < +stake) {
        return cb(lang.balanceLessStaking);
      }
      max = +balance;
      return cb(null, {
        min: min,
        max: max
      });
    };
    topupTheContract = function(){
      var type, stake, contractAddress, TimeLock, vlx2, vlxAddress;
      if (store.lockups.chosenLockup == null) {
        return alert(store, "please choose the contract", cb);
      }
      type = toString$.call(store.lockups.add.addValidatorTopup).slice(8, -1);
      if (type !== 'String' && type !== 'Number') {
        return alert(store, "please enter correct amount, got " + type, cb);
      }
      stake = times(store.lockups.add.addValidatorTopup, Math.pow(10, 18));
      contractAddress = store.lockups.chosenLockup.address;
      TimeLock = web3t.velas.Timelock.at(contractAddress);
      vlx2 = find(function(it){
        return it.coin.token === 'vlx2';
      })(
      store.current.account.wallets);
      vlxAddress = vlx2.address2;
      return TimeLock.getDefaultPool(function(err, lockedPool){
        var data, to, amount;
        if (err != null) {
          return cb(err);
        }
        data = TimeLock.stakeAmount.getData(vlxAddress, stake);
        to = TimeLock.address;
        amount = store.lockups.add.addValidatorTopup;
        return web3t.vlx2.sendTransaction({
          to: to,
          amount: amount
        }, function(err){
          if (err != null) {
            return cb(err);
          }
          if (err != null) {
            return store.lockups.add.result = err + "";
          }
          return cb(null);
        });
      });
    };
    stakeLockedToContract = function(){
      return canMakeStaking(store, web3t, function(err){
        var type, stake;
        if (err != null) {
          return alert(store, err, cb);
        }
        if (store.lockups.chosenLockup == null) {
          return alert(store, "please choose the contract", cb);
        }
        type = toString$.call(store.lockups.add.addValidatorStake).slice(8, -1);
        if (type !== 'String' && type !== 'Number') {
          return alert(store, "please enter correct amount, got " + type, cb);
        }
        stake = times(store.lockups.add.addValidatorStake, Math.pow(10, 18));
        return isEnoughToStake(store.lockups.add.addValidatorStake, div(store.lockups.chosenLockup.lockedFundsRaw, Math.pow(10, 18)), function(err){
          var contractAddress, TimeLock, vlx2, vlxAddress;
          if (err != null) {
            return alert(store, err + "", cb);
          }
          contractAddress = store.lockups.chosenLockup.address;
          TimeLock = web3t.velas.Timelock.at(contractAddress);
          vlx2 = find(function(it){
            return it.coin.token === 'vlx2';
          })(
          store.current.account.wallets);
          vlxAddress = vlx2.address2;
          return TimeLock.getDefaultPool(function(err, lockedPool){
            var data, to, amount;
            if (err != null) {
              return cb(err);
            }
            data = TimeLock.stake.getData(lockedPool, stake);
            to = TimeLock.address;
            amount = store.lockups.add.addValidatorStake;
            return web3t.vlx2.sendTransaction({
              to: to,
              data: data,
              amount: 0
            }, function(err){
              if (err != null) {
                return cb(err);
              }
              if (err != null) {
                return store.lockups.add.result = err + "";
              }
            });
          });
        });
      });
    };
    stakeToContract = function(){
      return canMakeStaking(store, web3t, function(err){
        var type;
        if (err != null) {
          return alert(store, err, cb);
        }
        if (store.lockups.chosenLockup == null) {
          return alert(store, "please choose the contract", cb);
        }
        type = toString$.call(store.lockups.add.addValidatorStake).slice(8, -1);
        if (type !== 'String' && type !== 'Number') {
          return alert(store, "please enter correct amount, got " + type, cb);
        }
        return isEnoughToStake(store.lockups.add.addValidatorStake, times(getBalance(), Math.pow(10, 18)), function(err){
          var stake, contractAddress, TimeLock, vlx2, vlxAddress;
          if (err != null) {
            return alert(store, err + "", cb);
          }
          stake = times(store.lockups.add.addValidatorStake, Math.pow(10, 18));
          contractAddress = store.lockups.chosenLockup.address;
          TimeLock = web3t.velas.Timelock.at(contractAddress);
          vlx2 = find(function(it){
            return it.coin.token === 'vlx2';
          })(
          store.current.account.wallets);
          vlxAddress = vlx2.address2;
          return TimeLock.getDefaultPool(function(err, lockedPool){
            var data, to, amount;
            if (err != null) {
              return cb(err);
            }
            data = TimeLock.stakeAmount.getData(vlxAddress, stake);
            to = TimeLock.address;
            amount = store.lockups.add.addValidatorStake;
            return web3t.vlx2.sendTransaction({
              to: to,
              amount: amount
            }, function(err){
              if (err != null) {
                return cb(err);
              }
              if (err != null) {
                return store.lockups.add.result = err + "";
              }
            });
          });
        });
      });
    };
    isForwardingEnabled = store.lockups.chosenLockup.isForwardingEnabled;
    stakeFunc = stakeLockedToContract;
    if (isForwardingEnabled) {
      stakeFunc = stakeToContract;
    }
    changeStake = function(it){
      var value, err;
      try {
        value = new bignumber(it.target.value).toFixed().toString();
        return store.lockups.add.addValidatorStake = value;
      } catch (e$) {
        err = e$;
        return console.log("[Change-stake]: " + err);
      }
    };
    useMin = function(){
      return store.lockups.add.addValidatorStake = 10000;
    };
    useMax = function(){
      var balance;
      balance = div(store.lockups.chosenLockup.lockedFundsRaw, Math.pow(10, 18));
      return store.lockups.add.addValidatorStake = Math.max(minus(balance, 0.1), 0);
    };
    epochNext = (ref$ = store.dashboard.epochNext) != null ? ref$ : 'loading...';
    if (!currentContractHasDefaultPool) {
      react.createElement('div', {
        className: 'section'
      }, children = [
        react.createElement('div', {
          className: 'title'
        }, children = react.createElement('h3', {}, ' ' + lang.stake)), react.createElement('div', {
          className: 'description'
        }, children = react.createElement('span', {}, ' No locked pool was found. Please select one before proceed'))
      ]);
    }
    return react.createElement('div', {}, children = [
      store.lockups.chosenLockup.isForwardingEnabled === false ? (useMinTopup = function(){
        return store.lockups.add.addValidatorTopup = 1;
      }, useMaxTopup = function(){
        var balance;
        balance = getBalance();
        return store.lockups.add.addValidatorTopup = Math.max(minus(balance, 0.1), 0);
      }, changeTopup = function(it){
        var value, err;
        try {
          value = new bignumber(it.target.value).toFixed().toString();
          return store.lockups.add.addValidatorTopup = value;
        } catch (e$) {
          err = e$;
          return console.log("[Change-topup]: " + err);
        }
      }, react.createElement('div', {
        className: 'section'
      }, children = [
        react.createElement('div', {
          className: 'title'
        }, children = react.createElement('h3', {}, ' Topup')), react.createElement('div', {
          className: 'description'
        }, children = react.createElement('div', {
          className: 'step-content'
        }, children = react.createElement('div', {
          className: 'left'
        }, children = [
          react.createElement('div', {
            className: 'balance'
          }, children = [
            react.createElement('span', {}, ' Your non-staked amount:'), react.createElement('span', {
              className: 'color'
            }, ' ' + lockedFunds), react.createElement('span', {
              className: 'color'
            }, ' ' + vlxToken)
          ]), amountField({
            store: store,
            value: store.lockups.add.addValidatorTopup,
            onChange: changeTopup,
            placeholder: 'Topup',
            token: "vlx2",
            id: "choose-staker-vlx-input"
          }), react.createElement('div', {
            className: 'balance'
          }, children = [
            react.createElement('span', {
              className: 'small-btns'
            }, children = [
              react.createElement('button', {
                style: buttonPrimary3Style,
                onClick: useMinTopup,
                className: 'small'
              }, ' ' + lang.min), react.createElement('button', {
                style: buttonPrimary3Style,
                onClick: useMaxTopup,
                className: 'small'
              }, ' ' + lang.max)
            ]), react.createElement('span', {}, ' ' + lang.balance + ':'), react.createElement('span', {
              className: 'color'
            }, ' ' + yourBalance), react.createElement('img', {
              src: icons.vlxIcon + "",
              className: 'label-coin'
            }), react.createElement('span', {
              className: 'color'
            }, ' ' + vlxToken)
          ]), button({
            store: store,
            onClick: topupTheContract,
            type: 'secondary',
            icon: 'apply',
            text: 'btnApply'
          })
        ])))
      ])) : void 8, lockedFundsRaw > 0 && store.lockups.chosenLockup.isForwardingEnabled === false ? react.createElement('div', {
        className: 'section'
      }, children = [
        react.createElement('div', {
          className: 'title'
        }, children = react.createElement('h3', {}, ' ' + lang.stake)), react.createElement('div', {
          className: 'description'
        }, children = react.createElement('div', {
          className: 'step-content'
        }, children = react.createElement('div', {
          className: 'left'
        }, children = [
          react.createElement('div', {
            className: 'balance'
          }, children = [
            react.createElement('span', {}, ' ' + lang.yourStaking + ':'), react.createElement('span', {
              className: 'color'
            }, ' ' + roundHuman(div(store.lockups.stakeAmountTotal, Math.pow(10, 18)))), react.createElement('span', {
              className: 'color'
            }, ' ' + vlxToken)
          ]), amountField({
            store: store,
            value: store.lockups.add.addValidatorStake,
            onChange: changeStake,
            placeholder: lang.stake,
            token: "vlx2",
            id: "choose-staker-vlx-input"
          }), react.createElement('div', {
            className: 'balance'
          }, children = [
            react.createElement('span', {
              className: 'small-btns'
            }, children = [
              react.createElement('button', {
                style: buttonPrimary3Style,
                onClick: useMin,
                className: 'small'
              }, ' ' + lang.min), react.createElement('button', {
                style: buttonPrimary3Style,
                onClick: useMax,
                className: 'small'
              }, ' ' + lang.max)
            ]), react.createElement('span', {}, ' Locked Amount:'), react.createElement('span', {
              className: 'color'
            }, ' ' + roundHuman(store.lockups.chosenLockup.lockedFunds)), react.createElement('img', {
              src: icons.vlxIcon + "",
              className: 'label-coin'
            }), react.createElement('span', {
              className: 'color'
            }, ' ' + vlxToken)
          ]), button({
            store: store,
            onClick: stakeFunc,
            type: 'secondary',
            icon: 'apply',
            text: 'btnApply'
          })
        ])))
      ]) : void 8, store.lockups.chosenLockup.isForwardingEnabled === true ? react.createElement('div', {
        className: 'section'
      }, children = [
        react.createElement('div', {
          className: 'title'
        }, children = react.createElement('h3', {}, ' ' + lang.stake)), react.createElement('div', {
          className: 'description'
        }, children = react.createElement('div', {
          className: 'step-content'
        }, children = react.createElement('div', {
          className: 'left'
        }, children = [
          react.createElement('div', {
            className: 'balance'
          }, children = [
            react.createElement('span', {}, ' ' + lang.yourStaking + ':'), react.createElement('span', {
              className: 'color'
            }, ' ' + roundHuman(div(store.lockups.stakeAmountTotal, Math.pow(10, 18)))), react.createElement('span', {
              className: 'color'
            }, ' ' + vlxToken)
          ]), amountField({
            store: store,
            value: store.lockups.add.addValidatorStake,
            onChange: changeStake,
            placeholder: lang.stake,
            token: "vlx2",
            id: "choose-staker-vlx-input"
          }), react.createElement('div', {
            className: 'balance'
          }, children = [
            react.createElement('span', {
              className: 'small-btns'
            }, children = [
              react.createElement('button', {
                style: buttonPrimary3Style,
                onClick: useMin,
                className: 'small'
              }, ' ' + lang.min), react.createElement('button', {
                style: buttonPrimary3Style,
                onClick: useMax,
                className: 'small'
              }, ' ' + lang.max)
            ]), react.createElement('span', {}, ' ' + lang.balance + ':'), react.createElement('span', {
              className: 'color'
            }, ' ' + roundHuman(store.lockups.chosenLockup.lockedFunds)), react.createElement('img', {
              src: icons.vlxIcon + "",
              className: 'label-coin'
            }), react.createElement('span', {
              className: 'color'
            }, ' ' + vlxToken)
          ]), button({
            store: store,
            onClick: stakeFunc,
            type: 'secondary',
            icon: 'apply',
            text: 'btnApply'
          })
        ])))
      ]) : void 8
    ]);
  };
  notAvailableRightNow = function(store){
    var lang, children;
    lang = getLang(store);
    return react.createElement('div', {
      className: 'section'
    }, children = [
      react.createElement('div', {
        className: 'title'
      }, children = react.createElement('h3', {}, ' ' + lang.exit)), react.createElement('div', {
        className: 'description'
      }, children = react.createElement('div', {}, ' ' + lang.actionProhibited))
    ]);
  };
  module.exports = function(store, web3t){
    return orderWithdrawProcess(store, web3t);
  };
  function bind$(obj, key, target){
    return function(){ return (target || obj)[key].apply(obj, arguments) };
  }
}).call(this);
