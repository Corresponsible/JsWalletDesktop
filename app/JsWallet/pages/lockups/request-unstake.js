// Generated by LiveScript 1.6.0
(function(){
  var react, reactDom, getPrimaryInfo, web3, getLang, icons, ref$, div, times, plus, minus, canMakeStaking, amountField, button, alert, moment, cb, orderWithdrawProcess, fastWithdrawProcess, notAvailableRightNow, registry;
  react = require('react');
  reactDom = require('react-dom');
  getPrimaryInfo = require('../../get-primary-info.js');
  web3 = require('../../web3.js');
  getLang = require('../../get-lang.js');
  icons = require('../../icons.js');
  ref$ = require('../../math.js'), div = ref$.div, times = ref$.times, plus = ref$.plus, minus = ref$.minus;
  canMakeStaking = require('../../staking/can-make-staking.js');
  amountField = require('../../components/amount-field.js');
  button = require('../../components/button.js');
  alert = require('../confirmation.js').alert;
  moment = require('moment');
  cb = bind$(console, 'log');
  orderWithdrawProcess = function(store, web3t){
    var lang, activate, activateFirst, activateSecond, activateThird, activeClass, activeFirst, activeSecond, activeThird, order, exit, changeMax, epochNext, ref$, amountRequested, unstakeIsAllowed, unstakeWaitTime, children;
    lang = getLang(store);
    activate = function(step){
      return function(){
        return store.lockups.exitTab = step;
      };
    };
    activateFirst = activate('exit_order');
    activateSecond = activate('exit_wait');
    activateThird = activate('exit_ordered');
    activeClass = function(step){
      if (store.lockups.exitTab === step) {
        return 'active';
      } else {
        return '';
      }
    };
    activeFirst = activeClass('exit_order');
    activeSecond = activeClass('exit_wait');
    activeThird = activeClass('exit_ordered');
    order = function(){
      return web3t.velas.Staking.areStakeAndWithdrawAllowed(function(err, data){
        var Timelock, lockedPoolAddress, lockupAddress;
        if (err != null) {
          return cb(err);
        }
        if (data !== true) {
          return alert(store, lang.exitNotAllowed, cb);
        }
        Timelock = store.lockups.currentTimelock;
        lockedPoolAddress = store.lockups.chosenLockup.lockedPool;
        lockupAddress = Timelock.address;
        return web3t.velas.Staking.maxWithdrawOrderAllowed(lockedPoolAddress, lockupAddress, function(err, max){
          var amount, data, to;
          console.log("maxWithdrawOrderAllowed", max);
          amount = times(store.lockups.withdrawAmount, Math.pow(10, 18));
          if (+amount > +max.toFixed()) {
            return alert(store, lang.max + " " + div(max.toFixed(), Math.pow(10, 18)));
          }
          if (+amount === 0) {
            return alert(store, lang.actionProhibited, cb);
          }
          console.log("Timelock 1", Timelock);
          data = Timelock.requestUnstake.getData(lockedPoolAddress, amount);
          to = lockupAddress;
          amount = 0;
          return web3t.vlx2.sendTransaction({
            to: to,
            data: data,
            amount: amount,
            gas: 4600000,
            gasPrice: 1000000
          }, function(err){});
        });
      });
    };
    exit = function(){
      var poolAddress, data, to, amount;
      console.log("exit request unstake");
      if (+store.lockups.orderedWithdrawAmount === 0) {
        return alert(store, lang.actionProhibited, cb);
      }
      poolAddress = store.lockups.chosenLockup.lockedPool;
      data = store.lockups.currentTimelock.claimUnstakeRequest.getData(poolAddress);
      to = store.lockups.currentTimelock.address;
      amount = 0;
      return web3t.vlx2.sendTransaction({
        to: to,
        data: data,
        amount: amount,
        gas: 4600000,
        gasPrice: 1000000
      }, function(err){});
    };
    changeMax = function(it){
      return store.lockups.withdrawAmount = it.target.value;
    };
    epochNext = (ref$ = store.dashboard.epochNext) != null ? ref$ : 'loading...';
    amountRequested = +store.lockups.orderedWithdrawAmount > 0 && store.lockups.waitForEpochChange;
    unstakeIsAllowed = +store.lockups.orderedWithdrawAmount > 0 && !store.lockups.waitForEpochChange;
    unstakeWaitTime = store.lockups.chosenLockup.unstakeWaitTime;
    return react.createElement('div', {
      className: 'section'
    }, children = [
      react.createElement('div', {
        className: 'title'
      }, children = react.createElement('h3', {}, ' Unstake')), react.createElement('div', {
        className: 'description'
      }, children = react.createElement('div', {
        className: 'left'
      }, children = react.createElement('div', {
        className: 'steps-holder steps-holder-2134779650'
      }, children = [
        react.createElement('div', {
          className: 'steps'
        }, children = [
          react.createElement('div', {
            onClickCommented: activateFirst,
            className: activeFirst + " step"
          }, children = [
            react.createElement('div', {
              className: 'step-count'
            }, ' 1'), react.createElement('div', {
              className: 'step-content'
            }, children = [
              react.createElement('div', {}, ' Request Unstake'), activeFirst === 'active' ? react.createElement('div', {}, children = [
                react.createElement('div', {}, children = amountField({
                  store: store,
                  value: store.lockups.withdrawAmount,
                  onChange: changeMax
                })), button({
                  store: store,
                  text: "Request Unstake",
                  icon: 'exit',
                  onClick: order,
                  type: "secondary"
                })
              ]) : void 8
            ])
          ]), react.createElement('div', {
            onClickCommented: activateSecond,
            className: activeSecond + " step"
          }, children = [
            react.createElement('div', {
              className: 'step-count'
            }, ' 2'), react.createElement('div', {
              className: 'step-content'
            }, '  Come back later for your unstaking amount')
          ]), react.createElement('div', {
            onClickCommented: activateThird,
            className: activeThird + " step"
          }, children = [
            react.createElement('div', {
              className: 'step-count'
            }, ' 3'), react.createElement('div', {
              className: 'step-content'
            }, children = [
              react.createElement('div', {}, ' Unstake'), activeThird === 'active' ? button({
                store: store,
                text: "Unstake",
                icon: 'exit',
                onClick: exit,
                type: "secondary"
              }) : void 8
            ])
          ])
        ]), react.createElement('div', {
          className: 'status-note'
        }, children = [
          amountRequested ? react.createElement('div', {
            className: 'note balance'
          }, children = [
            react.createElement('span', {
              className: 'color'
            }, ' ' + div(store.lockups.orderedWithdrawAmount, Math.pow(10, 18)) + ' '), react.createElement('span', {
              className: 'color'
            }, ' VLX '), react.createElement('span', {}, ' were requested to unstake and will be available'), react.createElement('span', {
              className: 'color'
            }, ' ' + unstakeWaitTime)
          ]) : void 8, unstakeIsAllowed ? react.createElement('div', {
            className: 'note balance'
          }, children = [
            react.createElement('span', {
              className: 'color'
            }, ' ' + div(store.lockups.orderedWithdrawAmount, Math.pow(10, 18)) + ' '), react.createElement('span', {
              className: 'color'
            }, ' VLX '), react.createElement('span', {}, ' are available to unstake ')
          ]) : void 8
        ])
      ])))
    ]);
  };
  fastWithdrawProcess = function(store, web3t){
    var lang, exit, changeMax, children;
    lang = getLang(store);
    exit = function(){
      return canMakeStaking(store, web3t, function(err){
        var stakingAddress, lockupAddress, lockedPoolAddress;
        if (err != null) {
          return alert(store, err, cb);
        }
        stakingAddress = store.lockups.keystore.lockups.address;
        lockupAddress = store.lockups.chosenPool.address;
        lockedPoolAddress = store.lockups.chosenPool.lockedPool;
        return web3t.velas.Staking.maxWithdrawAllowed(lockupAddress, stakingAddress, function(err, max){
          var amount, Timelock, data, to;
          return alert(store, "Max amount to withdraw is " + div(max, Math.pow(10, 18)));
          amount = times(store.lockups.withdrawAmount, Math.pow(10, 18));
          if (+amount > +max.toFixed()) {
            return alert(store, "Max amount to withdraw is " + div(max, Math.pow(10, 18)));
          }
          if (+amount === 0) {
            return alert(store, lang.actionProhibited, cb);
          }
          Timelock = store.lockups.currentTimelock;
          data = Timelock.unstake.getData(lockedPoolAddress, amount);
          to = lockupAddress;
          amount = 0;
          return web3t.vlx2.sendTransaction({
            to: to,
            data: data,
            amount: amount,
            gas: 4600000,
            gasPrice: 1000000
          }, function(err){});
        });
      });
    };
    changeMax = function(it){
      return store.lockups.withdrawAmount = it.target.value;
    };
    return react.createElement('div', {
      className: 'section'
    }, children = [
      react.createElement('div', {
        className: 'title'
      }, children = react.createElement('h3', {}, ' ' + lang.exit)), react.createElement('div', {
        className: 'description'
      }, children = [
        react.createElement('div', {}, ' ' + lang.withdraw), react.createElement('div', {}, children = amountField({
          store: store,
          value: store.lockups.withdrawAmount,
          onChange: changeMax
        })), button({
          store: store,
          text: lang.withdraw,
          icon: 'exit',
          onClick: exit,
          type: "secondary"
        })
      ])
    ]);
  };
  notAvailableRightNow = function(store){
    var lang, children;
    lang = getLang(store);
    return react.createElement('div', {
      className: 'section'
    }, children = [
      react.createElement('div', {
        className: 'title'
      }, children = react.createElement('h3', {}, ' Unstake')), react.createElement('div', {
        className: 'description'
      }, children = react.createElement('div', {
        className: 'balance'
      }, children = [
        react.createElement('span', {}, ' The action is not available till next epoch '), react.createElement('span', {
          className: 'color'
        }, ' (' + store.lockups.chosenLockup.tillNextEpoch + ')')
      ]))
    ]);
  };
  registry = {
    'exit_ordered': orderWithdrawProcess,
    'exit_order': orderWithdrawProcess,
    'exit_wait': orderWithdrawProcess,
    'exit': fastWithdrawProcess,
    'exit_closed': notAvailableRightNow
  };
  module.exports = function(store, web3t){
    var func;
    func = registry[store.lockups.exitTab];
    if (func == null) {
      return null;
    }
    return func(store, web3t);
  };
  module.exports.init = function(arg$, cb){
    var store, web3t, ref$, lockupAddress, lockedPoolAddress, TimeLock;
    store = arg$.store, web3t = arg$.web3t;
    console.log("init unstake", store);
    store.lockups.exitTab = '';
    store.lockups.maxWithdrawAllowed = 0;
    store.lockups.maxWithdrawOrderAllowed = 0;
    store.lockups.orderedWithdrawAmount = 0;
    store.lockups.chosenLockup.unstakeWaitTime = 0;
    if (((ref$ = store.lockups) != null ? ref$.chosenLockup : void 8) == null) {
      return cb(null);
    }
    lockupAddress = store.lockups.chosenLockup.address;
    lockedPoolAddress = store.lockups.chosenLockup.lockedPool;
    TimeLock = web3t.velas.Timelock.at(lockupAddress);
    return web3t.velas.Staking.maxWithdrawOrderAllowed(lockedPoolAddress, lockupAddress, function(err, max){
      if (err != null) {
        return cb(err);
      }
      store.lockups.maxWithdrawOrderAllowed = div(max.toFixed(), Math.pow(10, 18));
      if (+store.lockups.maxWithdrawOrderAllowed > 0) {
        store.lockups.withdrawAmount = store.lockups.maxWithdrawOrderAllowed;
      }
      return web3t.velas.Staking.orderedWithdrawAmount(lockedPoolAddress, lockupAddress, function(err, amount){
        if (err != null) {
          return cb(err);
        }
        store.lockups.orderedWithdrawAmount = amount.toFixed();
        return web3t.velas.Staking.orderWithdrawEpoch(lockedPoolAddress, lockupAddress, function(err, lastEpoch){
          if (err != null) {
            return cb(err + "");
          }
          console.log("last-epoch", lastEpoch);
          return web3t.velas.Staking.stakingEpoch(function(err, stakingEpoch){
            if (err != null) {
              return cb(err + "");
            }
            return web3t.velas.Staking.stakingEpochEndBlock(function(err, nextBlock){
              var block;
              block = plus(nextBlock, 1);
              return web3t.velas.web3.getBlockNumber(function(err, currentBlock){
                var seconds, next, res;
                seconds = times(minus(block, currentBlock), 5);
                if (err != null) {
                  return cb(err);
                }
                next = moment().add(seconds, 'seconds').fromNow();
                store.lockups.chosenLockup.tillNextEpoch = next;
                store.lockups.chosenLockup.unstakeWaitTime = next;
                console.log("staking-epoch", stakingEpoch);
                res = minus(stakingEpoch, lastEpoch);
                store.lockups.waitForEpochChange = +res <= 0 ? true : false;
                store.lockups.exitTab = (function(){
                  switch (false) {
                  case !(+store.lockups.orderedWithdrawAmount > 0 && store.lockups.waitForEpochChange):
                    return 'exit_wait';
                  case !(+store.lockups.orderedWithdrawAmount > 0):
                    return 'exit_ordered';
                  case !(+store.lockups.maxWithdrawAllowed > 0):
                    return 'exit';
                  case !(+store.lockups.maxWithdrawOrderAllowed > 0):
                    return 'exit_order';
                  case !(+store.lockups.stakeAmountTotal > 0):
                    return 'exit_closed';
                  default:
                    return '';
                  }
                }());
                return cb(null);
              });
            });
          });
        });
      });
    });
  };
  function bind$(obj, key, target){
    return function(){ return (target || obj)[key].apply(obj, arguments) };
  }
}).call(this);
