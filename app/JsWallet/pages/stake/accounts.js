// Generated by LiveScript 1.6.0
(function(){
  var react, reactDom, bignumber, navigate, getPrimaryInfo, getLang, historyFuncs, icon, ref$, map, split, filter, find, foldl, sortBy, unique, head, each, div, times, plus, minus, Buffer, ethToVlx, roundHuman, checkbox, icons, placeholder, canMakeStaking, button, addressHolder, addressHolderPopup, alertTxn, amountField, seedmem, moment, prompt2, promptStakeAccountAmount, alert, confirm, notify, pagination, asCallback, cb, showValidator, paginate, stakingAccountsContent, stakingAccounts, stringify, out$ = typeof exports != 'undefined' && exports || this;
  react = require('react');
  reactDom = require('react-dom');
  bignumber = require('bignumber.js');
  navigate = require('../../navigate.js');
  getPrimaryInfo = require('../../get-primary-info.js');
  getLang = require('../../get-lang.js');
  historyFuncs = require('../../history-funcs.js');
  icon = require('../icon.js');
  ref$ = require('prelude-ls'), map = ref$.map, split = ref$.split, filter = ref$.filter, find = ref$.find, foldl = ref$.foldl, sortBy = ref$.sortBy, unique = ref$.unique, head = ref$.head, each = ref$.each;
  ref$ = require('../../math.js'), div = ref$.div, times = ref$.times, plus = ref$.plus, minus = ref$.minus;
  Buffer = require('safe-buffer').Buffer;
  ethToVlx = require('../../../web3t/addresses.js').ethToVlx;
  roundHuman = require('../../round-human.js');
  checkbox = require('../../components/checkbox.js');
  icons = require('../../icons.js');
  placeholder = require('../placeholder.js');
  canMakeStaking = require('../../staking/can-make-staking.js');
  button = require('../../components/button.js');
  addressHolder = require('../../components/address-holder.js');
  addressHolderPopup = require('../../components/address-holder-popup.js');
  alertTxn = require('../alert-txn.js');
  amountField = require('../../components/amount-field.js');
  seedmem = require('../../seed.js');
  moment = require('moment');
  ref$ = require('../confirmation.js'), prompt2 = ref$.prompt2, promptStakeAccountAmount = ref$.promptStakeAccountAmount, alert = ref$.alert, confirm = ref$.confirm, notify = ref$.notify;
  pagination = require('../../components/pagination.js');
  asCallback = function(p, cb){
    p['catch'](function(err){
      return cb(err);
    });
    return p.then(function(data){
      return cb(null, data);
    });
  };
  cb = console.log;
  showValidator = function(store, web3t){
    return function(validator){
      return react.createElement('li', {}, ' ' + validator);
    };
  };
  out$.paginate = paginate = function(array, perPage, page){
    page = page - 1;
    return array.slice(page * perPage, (page + 1) * perPage);
  };
  stakingAccountsContent = function(store, web3t){
    var style, lang, buttonPrimary3Style, goBack, getBalance, getOptions, useMin, useMax, isSpinned, refresh, build, cancel, iconStyle, stakerPoolStyle, stats, notificationBorder, blockStyle, createStakingAccount, totalOwnStakingAccounts, ref$, loadingAccountIndex, perPage, page, paginationDisabled, children;
    style = getPrimaryInfo(store);
    lang = getLang(store);
    buttonPrimary3Style = {
      border: "1px solid " + style.app.primary3,
      color: style.app.text2,
      background: style.app.primary3,
      backgroundColor: style.app.primary3Spare
    };
    goBack = historyFuncs(store, web3t).goBack;
    lang = getLang(store);
    getBalance = function(){
      var wallet, ref$;
      wallet = find(function(it){
        return it.coin.token === 'vlx_native';
      })(
      store.current.account.wallets);
      return (ref$ = wallet != null ? wallet.balance : void 8) != null ? ref$ : 0;
    };
    getOptions = function(cb){
      return web3t.velas.Staking.candidateMinStake(function(err, data){
        var min, balance, stake, max;
        if (err != null) {
          return cb(err);
        }
        min = (function(){
          switch (false) {
          case !(+store.stakingAccounts.stakeAmountTotal >= 10000):
            return 1;
          default:
            return div(data, Math.pow(10, 18));
          }
        }());
        balance = minus(div(store.stakingAccounts.chosenLockup.lockedFundsRaw, Math.pow(10, 18)), 0.1);
        stake = store.stakingAccounts.add.addValidatorStake;
        if (10000 > +stake) {
          return cb(lang.amountLessStaking);
        }
        if (+balance < +stake) {
          return cb(lang.balanceLessStaking);
        }
        max = +balance;
        return cb(null, {
          min: min,
          max: max
        });
      });
    };
    useMin = function(){
      return store.stakingAccounts.add.addValidatorStake = 10000;
    };
    useMax = function(){
      var balance;
      balance = div(store.stakingAccounts.chosenLockup.lockedFundsRaw, Math.pow(10, 18));
      return store.stakingAccounts.add.addValidatorStake = Math.max(minus(balance, 0.1), 0);
    };
    isSpinned = (store.staking.allAccountsLoaded === false || store.staking.allAccountsLoaded == null) && store.staking.accountsAreLoading === true ? "spin disabled" : "";
    refresh = function(){
      if (store.staking.allAccountsLoaded !== true) {
        return;
      }
      store.staking.getAccountsFromCashe = false;
      return navigate(store, web3t, "validators");
    };
    build = function(store, web3t){
      return function(item){
        var index, account, address, balance, balanceRaw, key, rent, seed, status, validator, active_stake, inactive_stake, activationEpoch, ref$, ref1$, ref2$, ref3$, ref4$, deactivationEpoch, ref5$, ref6$, ref7$, ref8$, ref9$, activeBalanceIsZero, maxEpoch, isActivating, hasValidator, $status, vlx, wallet, walletValidator, undelegate, choose, stakeData, ref10$, ref11$, ref12$, ref13$, $button, disabled, children;
        index = item.seedIndex + 1;
        if (item == null || item.key == null) {
          return null;
        }
        account = item.account, address = item.address, balance = item.balance, balanceRaw = item.balanceRaw, key = item.key, rent = item.rent, seed = item.seed, status = item.status, validator = item.validator, active_stake = item.active_stake, inactive_stake = item.inactive_stake;
        activationEpoch = account != null ? (ref$ = account.data) != null ? (ref1$ = ref$.parsed) != null ? (ref2$ = ref1$.info) != null ? (ref3$ = ref2$.stake) != null ? (ref4$ = ref3$.delegation) != null ? ref4$.activationEpoch : void 8 : void 8 : void 8 : void 8 : void 8 : void 8;
        deactivationEpoch = account != null ? (ref5$ = account.data) != null ? (ref6$ = ref5$.parsed) != null ? (ref7$ = ref6$.info) != null ? (ref8$ = ref7$.stake) != null ? (ref9$ = ref8$.delegation) != null ? ref9$.deactivationEpoch : void 8 : void 8 : void 8 : void 8 : void 8 : void 8;
        activeBalanceIsZero = +active_stake === 0;
        maxEpoch = web3t.velas.NativeStaking.max_epoch;
        isActivating = activeBalanceIsZero && validator !== "";
        hasValidator = item.validator.toString().trim() !== "";
        $status = (function(){
          switch (false) {
          case !(item.status === "inactive" && !hasValidator):
            return "Not Delegated";
          case !(item.status === "inactive" && hasValidator):
            return "Delegated (Inactive)";
          default:
            return status;
          }
        }());
        vlx = find(function(it){
          return it.coin.token === 'vlx_native';
        })(
        store.current.account.wallets);
        if (vlx == null) {
          return null;
        }
        wallet = {
          address: item.address,
          network: vlx.network,
          coin: vlx.coin
        };
        walletValidator = {
          address: validator,
          network: vlx.network,
          coin: vlx.coin
        };
        undelegate = function(){
          var undelegateAmount;
          undelegateAmount = item.balance;
          return confirm(store, lang.areYouSureToUndelegate + (" " + undelegateAmount + " VLX \nfrom " + item.validator + " ?"), function(agree){
            if (agree === false) {
              return;
            }
            return asCallback(web3t.velas.NativeStaking.undelegate(item.address), function(err, result){
              if (err != null) {
                console.error("Undelegate error: ", err);
              }
              if (err != null) {
                return alert(store, err.toString());
              }
              return notify(store, lang.fundsUndelegated, function(){
                store.staking.getAccountsFromCashe = false;
                return navigate(store, web3t, 'validators');
              });
            });
          });
        };
        choose = function(){
          store.staking.chosenAccount = item;
          navigate(store, web3t, 'poolchoosing');
          return cb(null);
        };
        stakeData = item != null ? (ref10$ = item.account) != null ? (ref11$ = ref10$.data) != null ? (ref12$ = ref11$.parsed) != null ? (ref13$ = ref12$.info) != null ? ref13$.stake : void 8 : void 8 : void 8 : void 8 : void 8;
        $button = (function(){
          var ref$;
          switch (false) {
          case item.status !== 'inactive':
            return button({
              store: store,
              text: lang.to_delegate,
              onClick: choose,
              type: 'secondary',
              icon: 'arrowRight'
            });
          default:
            disabled = item.status === 'deactivating';
            if (stakeData != null && stakeData.delegation != null) {
              ref$ = stakeData.delegation, activationEpoch = ref$.activationEpoch, deactivationEpoch = ref$.deactivationEpoch;
              if (+activationEpoch < +deactivationEpoch && +deactivationEpoch !== +maxEpoch) {
                disabled = true;
              }
            }
            return button({
              store: store,
              classes: "action-undelegate",
              text: lang.to_undelegate,
              onClick: undelegate,
              type: 'secondary',
              icon: 'arrowLeft',
              makeDisabled: disabled
            });
          }
        }());
        return react.createElement('tr', {
          key: address + "",
          className: item.status + ""
        }, children = [
          react.createElement('td', {}, children = react.createElement('span', {
            className: item.status + " circle"
          }, ' ' + index)), react.createElement('td', {
            datacolumn: 'Staker Address',
            title: address + ""
          }, children = addressHolderPopup({
            store: store,
            wallet: wallet,
            item: item
          })), react.createElement('td', {}, ' ' + balance), react.createElement('td', {
            title: validator + "",
            className: "validator-address"
          }, children = validator != null && validator !== "" ? addressHolderPopup({
            store: store,
            wallet: walletValidator,
            item: item
          }) : "---"), react.createElement('td', {}, ' ' + seed), false ? react.createElement('td', {
            className: "account-status " + status
          }, ' ' + $status) : void 8, react.createElement('td', {}, children = $button)
        ]);
      };
    };
    cancel = function(){
      store.stakingAccounts.chosenLockup = null;
      return store.stakingAccounts.add.addValidatorStake = 0;
    };
    iconStyle = {
      color: style.app.loader,
      marginTop: "10px",
      width: "inherit"
    };
    stakerPoolStyle = {
      maxWidth: 200,
      background: style.app.stats
    };
    stats = {
      background: style.app.stats
    };
    notificationBorder = {
      border: "1px solid orange",
      padding: 5,
      borderRadius: 5,
      width: "auto",
      margin: "10px 20px 0"
    };
    blockStyle = {
      display: "block"
    };
    createStakingAccount = function(){
      var cb;
      cb = console.log;
      return asCallback(web3t.velas.NativeStaking.getStakingAccounts(store.staking.parsedProgramAccounts), function(err){
        if (err != null) {
          console.error(err);
        }
        return prompt2(store, lang.howMuchToDeposit, function(amount){
          var min_stake, main_balance, txFee, rest;
          if (amount == null) {
            return;
          }
          if (amount + "".trim().length === 0) {
            return;
          }
          min_stake = web3t.velas.NativeStaking.min_stake;
          main_balance = getBalance();
          txFee = div(5000, Math.pow(10, 9));
          rest = 0.1;
          if (+minus(main_balance, amount) <= 0) {
            amount = minus(amount, plus(plus(store.staking.rent, txFee), rest));
          }
          if (+min_stake > +main_balance) {
            return alert(store, lang.balanceIsNotEnoughToCreateStakingAccount);
          }
          if (+min_stake > +amount) {
            return alert(store, lang.minimalStakeMustBe + (" " + min_stake + " VLX"));
          }
          if (+main_balance < +amount) {
            return alert(store, lang.balanceIsNotEnoughToSpend + (" " + amount + " VLX"));
          }
          amount = amount * Math.pow(10, 9);
          return asCallback(web3t.velas.NativeStaking.createAccount(amount), function(err, result){
            var ref$;
            if (err != null) {
              console.error("Result sending:", err);
            }
            if (err != null) {
              if (((ref$ = err.toString()) != null ? ref$ : "").indexOf("custom program error: 0x1") > -1) {
                err = lang.balanceIsNotEnoughToCreateStakingAccount;
              }
            }
            if (err != null) {
              return alert(store, err.toString());
            }
            store.staking.getAccountsFromCashe = false;
            return setTimeout(function(){
              return notify(store, lang.accountCreatedAndFundsDeposited, function(){
                return navigate(store, web3t, "validators");
              });
            }, 1000);
          });
        });
      });
    };
    totalOwnStakingAccounts = (ref$ = store.staking.totalOwnStakingAccounts) != null ? ref$ : 0;
    loadingAccountIndex = Math.min(totalOwnStakingAccounts, store.staking.loadingAccountIndex);
    perPage = store.staking.accounts_per_page;
    page = store.staking.current_accounts_page;
    paginationDisabled = store.staking.accountsAreLoading === true;
    return react.createElement('div', {
      className: 'staking-accounts-content staking-accounts-content-1295497501'
    }, children = [
      react.createElement('div', {}, children = react.createElement('div', {
        id: "create-staking-account",
        className: 'form-group'
      }, children = react.createElement('div', {
        className: 'section create-staking-account'
      }, children = [
        react.createElement('div', {
          className: 'title'
        }, children = react.createElement('h3', {}, ' ' + lang.createStakingAccount)), react.createElement('div', {
          className: 'description'
        }, children = [
          react.createElement('span', {}, children = button({
            store: store,
            classes: "width-auto",
            text: lang.createAccount,
            noIcon: true,
            onClick: createStakingAccount,
            style: {
              width: 'auto',
              display: 'block'
            }
          })), store.staking.accounts.length === 0
            ? react.createElement('span', {
              style: notificationBorder,
              className: 'notification-entity'
            }, ' Please create a staking account before you stake')
            : react.createElement('span', {
              style: notificationBorder,
              className: 'notification-entity'
            }, ' ' + lang.youCanStakeMore)
        ])
      ]))), react.createElement('div', {}, children = react.createElement('div', {
        id: "staking-accounts",
        className: 'form-group'
      }, children = react.createElement('div', {
        className: 'section'
      }, children = [
        react.createElement('div', {
          className: 'title'
        }, children = [
          react.createElement('h3', {
            className: 'section-title'
          }, ' ' + lang.yourStakingAccounts + ' '), react.createElement('span', {
            className: 'amount'
          }, ' (' + store.staking.accounts.length + ') '), react.createElement('div', {}, children = react.createElement('div', {
            onClick: refresh,
            style: iconStyle,
            title: "refresh",
            className: isSpinned + " loader"
          }, children = icon('Sync', 25)))
        ]), react.createElement('div', {
          className: 'description'
        }, children = [
          store.staking.accountsAreLoading === false
            ? react.createElement('div', {
              className: 'table-scroll'
            }, children = react.createElement('table', {}, children = [
              react.createElement('thead', {}, children = react.createElement('tr', {}, children = [
                react.createElement('td', {
                  width: "3%",
                  style: stats
                }, ' #'), react.createElement('td', {
                  width: "40%",
                  style: stakerPoolStyle,
                  title: "Your Staking Account"
                }, ' ' + lang.account + ' (?)'), react.createElement('td', {
                  width: "10%",
                  style: stats,
                  title: "Your Deposited Balance"
                }, ' ' + lang.balance + ' (?)'), react.createElement('td', {
                  width: "30%",
                  style: stats,
                  title: "Where you staked"
                }, ' ' + lang.validator + ' (?)'), react.createElement('td', {
                  width: "7%",
                  style: stats,
                  title: "The ID of your stake. This is made to simplify the search of your stake in validator list"
                }, ' ' + lang.seed + ' (?)'), false ? react.createElement('td', {
                  width: "10%",
                  style: stats,
                  title: "Current staking status. Please notice that you cannot stake / unstake immediately. You need to go through the waiting period. This is made to reduce attacks by staking and unstaking spam."
                }, ' ' + lang.status + ' (?)') : void 8, react.createElement('td', {
                  width: "10%",
                  style: stats
                }, ' ' + ((ref$ = lang.action) != null ? ref$ : "Action"))
              ])), react.createElement('tbody', {}, children = map(build(store, web3t))(
              paginate(sortBy(function(it){
                return it.seedIndex;
              })(
              store.staking.accounts), perPage, page)))
            ]))
            : react.createElement('div', {
              className: 'table-scroll'
            }, children = react.createElement('span', {
              className: 'entities-loader'
            }, children = react.createElement('span', {
              className: 'inner-section'
            }, children = [
              react.createElement('h3', {
                className: 'item blink'
              }, ' Loading...'), react.createElement('span', {
                className: 'item'
              }, '  ' + loadingAccountIndex), react.createElement('span', {
                className: 'item'
              }, ' of'), react.createElement('span', {
                className: 'item'
              }, '  ' + totalOwnStakingAccounts)
            ]))), pagination({
            store: store,
            type: 'accounts',
            disabled: paginationDisabled,
            config: {
              array: store.staking.accounts
            }
          })
        ])
      ])))
    ]);
  };
  stakingAccounts = function(arg$){
    var store, web3t, children;
    store = arg$.store, web3t = arg$.web3t;
    return react.createElement('div', {
      className: 'staking-accounts-content staking-accounts-content-1295497501'
    }, children = stakingAccountsContent(store, web3t));
  };
  stringify = function(value){
    if (value != null) {
      return roundHuman(parseFloat(div(value, Math.pow(10, 18))));
    } else {
      return '..';
    }
  };
  module.exports = stakingAccounts;
}).call(this);
