// Generated by LiveScript 1.6.0
(function(){
  var react, reactDom, navigate, getPrimaryInfo, web3, bignumber, getLang, historyFuncs, getAllActiveStake, icon, ref$, map, split, filter, find, foldl, sortBy, unique, head, each, div, times, plus, minus, velasNodeTemplate, hdkey, bip39, md5, menuFuncs, btoa, Buffer, copiedInform, copy, round5, ethToVlx, vlxToEth, switchAccount, roundHuman, roundNumber, icons, placeholder, epoch, alert, notify, confirm, prompt2, prompt3, button, addressHolder, alertTxn, amountField, seedmem, burger, getErrorMessage, rewardsStats, cb, asCallback, toKeystore, showValidator, stakingContent, accountDetails, stringify, fetchEpochRewards, prevEpochData, queryRewardsLoop, get_first_slot_in_epoch, tryGetExtraSlot, get_confirmed_block_with_encoding, retrieveRewardData;
  react = require('react');
  reactDom = require('react-dom');
  navigate = require('../../navigate.js');
  getPrimaryInfo = require('../../get-primary-info.js');
  web3 = require('../../web3.js');
  bignumber = require('bignumber.js');
  getLang = require('../../get-lang.js');
  historyFuncs = require('../../history-funcs.js');
  getAllActiveStake = require('../../staking-funcs.js').getAllActiveStake;
  icon = require('../icon.js');
  ref$ = require('prelude-ls'), map = ref$.map, split = ref$.split, filter = ref$.filter, find = ref$.find, foldl = ref$.foldl, sortBy = ref$.sortBy, unique = ref$.unique, head = ref$.head, each = ref$.each;
  ref$ = require('../../math.js'), div = ref$.div, times = ref$.times, plus = ref$.plus, minus = ref$.minus;
  velasNodeTemplate = require('../../velas/velas-node-template.js');
  ref$ = require('../../../web3t/providers/deps.js'), hdkey = ref$.hdkey, bip39 = ref$.bip39;
  md5 = require('md5');
  menuFuncs = require('../../menu-funcs.js');
  btoa = require('btoa');
  Buffer = require('safe-buffer').Buffer;
  copiedInform = require('../../copied-inform.js');
  copy = require('../../copy.js');
  round5 = require('../../round5.js');
  ref$ = require('../../../web3t/addresses.js'), ethToVlx = ref$.ethToVlx, vlxToEth = ref$.vlxToEth;
  switchAccount = require('../switch-account.js');
  roundHuman = require('../../round-human.js');
  roundNumber = require('../../round-number.js');
  icons = require('../../icons.js');
  placeholder = require('../placeholder.js');
  epoch = require('../epoch.js');
  ref$ = require('../confirmation.js'), alert = ref$.alert, notify = ref$.notify, confirm = ref$.confirm, prompt2 = ref$.prompt2, prompt3 = ref$.prompt3;
  button = require('../../components/button.js');
  addressHolder = require('../../components/address-holder.js');
  alertTxn = require('../alert-txn.js');
  amountField = require('../../components/amount-field.js');
  seedmem = require('../../seed.js');
  burger = require('../../components/burger.js');
  getErrorMessage = require('./error-funcs.js').getErrorMessage;
  rewardsStats = require('./rewards-stats.js');
  cb = console.log;
  asCallback = function(p, cb){
    p['catch'](function(err){
      return cb(err);
    });
    return p.then(function(data){
      return cb(null, data);
    });
  };
  toKeystore = function(store, withKeystore){
    var mnemonic, seed, wallet, index, password, staking, mining;
    mnemonic = seedmem.mnemonic;
    seed = bip39.mnemonicToSeed(mnemonic);
    wallet = hdkey.fromMasterSeed(seed);
    index = store.current.accountIndex;
    password = md5(wallet.derivePath("m1").deriveChild(index).getWallet().getAddress().toString('hex'));
    staking = (function(){
      switch (false) {
      case store.urlParams.anotheracc == null:
        return {
          address: window.toEthAddress(store.urlParams.anotheracc)
        };
      default:
        return getPair(wallet, 'm0', index, password, false);
      }
    }());
    mining = getPair(wallet, 'm0/2', index, password, withKeystore);
    return {
      staking: staking,
      mining: mining,
      password: password
    };
  };
  showValidator = function(store, web3t){
    return function(validator){
      return react.createElement('li', {}, ' ' + validator);
    };
  };
  stakingContent = function(store, web3t){
    var goBack, style, lang, buttonPrimary3Style, seedStyle, filterIcon, commingSoon, pairs, iStakeChoosenPool, wallet, delegate, velasNodeAppliedTemplate, velasNodeAppliedTemplateLine, ref$, accountLeft, accountRight, changeAccountIndex, updateCurrent, accountLeftProxy, accountRightProxy, changeAccountIndexProxy, lineStyle, activate, activateLine, activateString, activateSsh, activateDo, activeClass, activeLine, activeString, activeSsh, activeDo, getBalance, getOptions, useMin, useMax, yourBalance, isSpinned, cancelPool, refresh, withdraw, undelegate, splitAccount, iconStyle, stakerPoolStyle, stats, hasValidator, credits_observed, ref1$, active_stake, inactive_stake, delegated_stake, usdRate, usdBalance, usdRent, usdActive_stake, usdInactive_stake, usdDelegated_stake, $validator, activationEpoch, ref2$, ref3$, ref4$, ref5$, deactivationEpoch, ref6$, ref7$, ref8$, ref9$, ref10$, activeBalanceIsZero, maxEpoch, myStakeMaxPart, myStakeMaxPartVLX, $status, inactiveStakeLabel, buildRewards, children, moreStyle, tipStyle, linkStyle, notificationStyle;
    goBack = historyFuncs(store, web3t).goBack;
    style = getPrimaryInfo(store);
    lang = getLang(store);
    buttonPrimary3Style = {
      border: "1px solid " + style.app.primary3,
      color: style.app.text2,
      background: style.app.primary3,
      backgroundColor: style.app.primary3Spare
    };
    seedStyle = {
      background: style.app.primary2,
      backgroundColor: style.app.primary2Spare,
      padding: 5
    };
    filterIcon = {
      filter: style.app.filterIcon
    };
    commingSoon = {
      opacity: ".3"
    };
    pairs = store.staking.keystore;
    iStakeChoosenPool = function(){
      var account, myStake;
      account = store.staking.chosenAccount;
      myStake = +account.myStake;
      return myStake >= 10000;
    };
    wallet = find(function(it){
      return it.coin.token === 'vlx_native';
    })(
    store.current.account.wallets);
    delegate = function(){
      var account, payAccount;
      if (wallet == null) {
        return null;
      }
      if (store.staking.chosenAccount == null) {
        return alert(store, "please choose the account", cb);
      }
      account = store.staking.chosenAccount;
      payAccount = find(function(it){
        return it.address === account.address;
      })(
      store.staking.accounts);
      if (!payAccount) {
        return cb(null);
      }
      console.log("");
      return asCallback(web3t.velas.NativeStaking.delegate(payAccount.address, account.address), function(err, result){
        var errMessage;
        if (err != null) {
          console.error("Result sending:", err);
        }
        errMessage = getErrorMessage(err, result);
        if (errMessage != null) {
          return alert(store, errMessage);
        }
        return notify(store, "FUNDS DELEGATED", function(){
          return navigate(store, web3t, 'validators');
        });
      });
    };
    velasNodeAppliedTemplate = split("\n")(
    velasNodeTemplate(
    pairs));
    velasNodeAppliedTemplateLine = function(it){
      return "echo '" + it + "' | base64 --decode | sh";
    }(
    btoa(
    velasNodeTemplate(
    pairs)));
    if (pairs.mining == null) {
      return null;
    }
    ref$ = menuFuncs(store, web3t), accountLeft = ref$.accountLeft, accountRight = ref$.accountRight, changeAccountIndex = ref$.changeAccountIndex;
    updateCurrent = function(func){
      return function(data){
        func(data);
        return staking.init({
          store: store,
          web3t: web3t
        }, function(){
          return store.staking.keystore = toKeystore(store, false);
        });
      };
    };
    accountLeftProxy = updateCurrent(accountLeft);
    accountRightProxy = updateCurrent(accountRight);
    changeAccountIndexProxy = updateCurrent(changeAccountIndex);
    lineStyle = {
      padding: "10px",
      width: '100%'
    };
    activate = function(tab){
      return function(){
        return store.staking.tab = tab;
      };
    };
    activateLine = activate('line');
    activateString = activate('string');
    activateSsh = activate('ssh');
    activateDo = activate('do');
    activeClass = function(tab){
      if (store.staking.tab === tab) {
        return 'active';
      } else {
        return '';
      }
    };
    activeLine = activeClass('line');
    activeString = activeClass('string');
    activeSsh = activeClass('ssh');
    activeDo = activeClass('do');
    getBalance = function(){
      var wallet;
      wallet = find(function(it){
        return it.coin.token === 'vlx2';
      })(
      store.current.account.wallets);
      return wallet.balance;
    };
    getOptions = function(cb){
      var iAmStaker;
      iAmStaker = iStakeChoosenPool();
      if (iAmStaker) {
        return cb(null);
      }
      return web3t.velas.Staking.candidateMinStake(function(err, data){
        var min, balance, stake, max;
        if (err != null) {
          return cb(err);
        }
        min = (function(){
          switch (false) {
          case !(+store.staking.stakeAmountTotal >= 10000):
            return 1;
          default:
            return div(data, Math.pow(10, 18));
          }
        }());
        balance = minus(getBalance(), 0.1);
        stake = store.staking.add.addValidatorStake;
        if (10000 > +stake) {
          return cb(lang.amountLessStaking);
        }
        if (+balance < +stake) {
          return cb(lang.balanceLessStaking);
        }
        max = +balance;
        return cb(null, {
          min: min,
          max: max
        });
      });
    };
    useMin = function(){
      return store.staking.add.addValidatorStake = 10000;
    };
    useMax = function(){
      return store.staking.add.addValidatorStake = Math.max(minus(getBalance(), 0.1), 0);
    };
    yourBalance = plus(div(store.staking.chosenAccount.balanceRaw, Math.pow(10, 9)), store.staking.chosenAccount.rent);
    isSpinned = (store.staking.allPoolsLoaded === false || store.staking.allPoolsLoaded == null) && store.staking.poolsAreLoading === true ? "spin disabled" : "";
    cancelPool = function(){
      return store.staking.chosenAccount = null;
    };
    refresh = function(){
      var cb;
      store.staking.allPoolsLoaded = false;
      store.staking.getAccountsFromCashe = false;
      if ((store.staking.allPoolsLoaded === false || store.staking.allPoolsLoaded == null) && store.staking.poolsAreLoading === true) {
        return false;
      }
      store.staking.poolsAreLoading = true;
      cb = console.log;
      return staking.init({
        store: store,
        web3t: web3t
      }, function(err){
        if (err != null) {
          return cb(err);
        }
        return cb(null, 'done');
      });
    };
    withdraw = function(){
      return confirm(store, lang.areYouSureToWithdraw, function(agree){
        var ref$, balanceRaw, rent, address, account, amount;
        if (agree === false) {
          return;
        }
        ref$ = store.staking.chosenAccount, balanceRaw = ref$.balanceRaw, rent = ref$.rent, address = ref$.address, account = ref$.account;
        amount = plus(account.lamports, rent);
        return asCallback(web3t.velas.NativeStaking.withdraw(address, amount), function(err, result){
          var errMessage;
          errMessage = getErrorMessage(err, result);
          if (errMessage != null) {
            return alert(store, errMessage);
          }
          return setTimeout(function(){
            return notify(store, lang.fundsWithdrawn, function(){
              store.staking.getAccountsFromCashe = false;
              return navigate(store, web3t, 'validators');
            });
          }, 1000);
        });
      });
    };
    delegate = function(){
      return navigate(store, web3t, 'poolchoosing');
    };
    undelegate = function(){
      return confirm(store, lang.areYouSureToUndelegate, function(agree){
        if (agree === false) {
          return;
        }
        return asCallback(web3t.velas.NativeStaking.undelegate(store.staking.chosenAccount.address), function(err, result){
          var errMessage;
          if (err != null) {
            console.error("Undelegate error: ", err);
          }
          errMessage = getErrorMessage(err, result);
          if (errMessage != null) {
            return alert(store, errMessage);
          }
          return setTimeout(function(){
            return notify(store, lang.fundsUndelegated, function(){
              store.staking.getAccountsFromCashe = false;
              return navigate(store, web3t, 'validators');
            });
          }, 1000);
        });
      });
    };
    splitAccount = function(){
      var cb;
      cb = console.log;
      return asCallback(web3t.velas.NativeStaking.getStakingAccounts(store.staking.parsedProgramAccounts), function(err){
        if (err != null) {
          console.error(err);
        }
        /* Get next account seed */
        return asCallback(web3t.velas.NativeStaking.getNextSeed(), function(err, seed){
          var errMessage;
          errMessage = getErrorMessage(err, seed);
          if (errMessage != null) {
            return alert(store, errMessage);
          }
          /**/
          return prompt3(store, lang.howMuchToSplit, function(amount){
            var min_stake, balance, fromPubkey$;
            if (amount + "".trim().length === 0) {
              return;
            }
            min_stake = web3t.velas.NativeStaking.min_stake;
            balance = store.staking.chosenAccount.balanceRaw;
            if (+amount > +balance) {
              return alert(store, lang.balanceIsNotEnoughToSpend + (" " + amount + " VLX"));
            }
            if (+min_stake > +balance) {
              return alert(store, lang.balanceIsNotEnoughToCreateStakingAccount + (" (" + plus(min_stake, 0.00228288) + " VLX)"));
            }
            if (+min_stake > +amount) {
              return alert(store, lang.minimalStakeMustBe + (" " + min_stake + " VLX"));
            }
            amount = amount * Math.pow(10, 9);
            /* Create new account */
            fromPubkey$ = store.staking.chosenAccount.address;
            return asCallback(web3t.velas.NativeStaking.createNewStakeAccountWithSeed(), function(err, splitStakePubkey){
              var stakeAccount;
              if (err != null) {
                return alert(store, err.toString());
              }
              /**/
              /* Split account */
              stakeAccount = store.staking.chosenAccount.address;
              return asCallback(web3t.velas.NativeStaking.splitStakeAccount(stakeAccount, splitStakePubkey, amount), function(err, result){
                var errMessage;
                errMessage = getErrorMessage(err, result);
                if (errMessage != null) {
                  return alert(store, errMessage);
                }
                return setTimeout(function(){
                  return notify(store, lang.accountCreatedAndFundsSplitted, function(){
                    store.staking.getAccountsFromCashe = false;
                    return navigate(store, web3t, "validators");
                  });
                }, 500);
              });
            });
          });
        });
      });
    };
    iconStyle = {
      color: style.app.loader,
      marginTop: "10px",
      width: "inherit"
    };
    stakerPoolStyle = {
      maxWidth: 200,
      background: style.app.stats
    };
    stats = {
      background: style.app.stats
    };
    hasValidator = store.staking.chosenAccount.validator.toString().trim() !== "";
    credits_observed = (ref$ = (ref1$ = store.staking.chosenAccount) != null ? ref1$.credits_observed : void 8) != null ? ref$ : 0;
    active_stake = div(store.staking.chosenAccount.active_stake, Math.pow(10, 9));
    inactive_stake = div(store.staking.chosenAccount.inactive_stake, Math.pow(10, 9));
    delegated_stake = plus(active_stake, inactive_stake);
    usdRate = (ref$ = wallet != null ? wallet.usdRate : void 8) != null ? ref$ : 0;
    usdBalance = roundNumber(times(yourBalance, usdRate), {
      decimals: 2
    });
    usdRent = roundNumber(times(store.staking.chosenAccount.rent, usdRate), {
      decimals: 2
    });
    usdActive_stake = roundNumber(times(active_stake, usdRate), {
      decimals: 2
    });
    usdInactive_stake = roundNumber(times(inactive_stake, usdRate), {
      decimals: 2
    });
    usdDelegated_stake = roundNumber(times(delegated_stake, usdRate), {
      decimals: 2
    });
    $validator = store.staking.chosenAccount.validator === ""
      ? "---"
      : store.staking.chosenAccount.validator;
    activationEpoch = typeof account != 'undefined' && account !== null ? (ref$ = account.data) != null ? (ref2$ = ref$.parsed) != null ? (ref3$ = ref2$.info) != null ? (ref4$ = ref3$.stake) != null ? (ref5$ = ref4$.delegation) != null ? ref5$.activationEpoch : void 8 : void 8 : void 8 : void 8 : void 8 : void 8;
    deactivationEpoch = typeof account != 'undefined' && account !== null ? (ref6$ = account.data) != null ? (ref7$ = ref6$.parsed) != null ? (ref8$ = ref7$.info) != null ? (ref9$ = ref8$.stake) != null ? (ref10$ = ref9$.delegation) != null ? ref10$.deactivationEpoch : void 8 : void 8 : void 8 : void 8 : void 8 : void 8;
    activeBalanceIsZero = +store.staking.chosenAccount.active_stake === 0;
    maxEpoch = web3t.velas.NativeStaking.max_epoch;
    myStakeMaxPart = (function(){
      switch (false) {
      case store.staking.myStakeMaxPart == null:
        myStakeMaxPartVLX = div(parseFloat(store.staking.myStakeMaxPart), Math.pow(10, 9));
        return myStakeMaxPartVLX + " VLX";
      default:
        return "";
      }
    }());
    $status = (function(){
      switch (false) {
      case !(store.staking.chosenAccount.status === "inactive" && !hasValidator):
        return "Not Delegated";
      case !(store.staking.chosenAccount.status === "inactive" && hasValidator):
        return "Delegated (Inactive)";
      case store.staking.chosenAccount.status !== "activating":
        return "";
      default:
        return store.staking.chosenAccount.status;
      }
    }());
    inactiveStakeLabel = (function(){
      switch (false) {
      case store.staking.chosenAccount.status !== "activating":
        return lang.warminUp;
      default:
        return lang.inactiveStake;
      }
    }());
    buildRewards = function(item){
      var epoch, rewardSlot, amount, newBalance, percentChange, apr, $amount, $newBalance, $class, $trClass, children;
      epoch = item.epoch, rewardSlot = item.rewardSlot, amount = item.amount, newBalance = item.newBalance, percentChange = item.percentChange, apr = item.apr;
      if (epoch === store.staking.currentEpoch) {
        return null;
      }
      $amount = div(amount, Math.pow(10, 9));
      $newBalance = div(newBalance, Math.pow(10, 9));
      if (store.staking.currentEpoch === epoch) {
        rewardSlot = $amount = $newBalance = percentChange = apr = "Loading...";
      }
      $class = epoch === store.staking.currentEpoch ? "syncing" : "";
      $trClass = epoch === store.staking.currentEpoch ? "current-epoch " : "";
      return react.createElement('tr', {
        key: "epoch" + epoch,
        className: $trClass + ""
      }, children = [
        react.createElement('td', {
          className: $class + ""
        }, ' ' + epoch), react.createElement('td', {
          className: $class + ""
        }, ' ' + rewardSlot), react.createElement('td', {
          className: $class + ""
        }, ' ' + $amount), react.createElement('td', {
          className: $class + ""
        }, ' ' + $newBalance), react.createElement('td', {
          className: $class + ""
        }, ' ' + percentChange), react.createElement('td', {
          className: $class + ""
        }, ' ' + apr)
      ]);
    };
    return react.createElement('div', {
      className: 'staking-content delegate'
    }, children = react.createElement('div', {
      id: "choosen-pull",
      className: 'single-section form-group'
    }, children = [
      react.createElement('div', {
        className: 'section'
      }, children = react.createElement('div', {
        className: 'title'
      }, children = react.createElement('h2', {}, ' ' + lang.stakeAccount))), react.createElement('div', {
        className: 'section'
      }, children = [
        react.createElement('div', {
          className: 'title'
        }, children = react.createElement('h3', {}, ' ' + lang.address)), react.createElement('div', {
          className: 'description'
        }, children = react.createElement('div', {
          title: store.staking.chosenAccount.address + "",
          className: 'chosen-account'
        }, children = react.createElement('span', {}, children = [
          " " + store.staking.chosenAccount.address, react.createElement('img', {
            src: icons.imgCheck + "",
            className: 'check'
          })
        ])))
      ]), react.createElement('div', {
        className: 'section'
      }, children = [
        react.createElement('div', {
          className: 'title'
        }, children = react.createElement('h3', {}, ' ' + lang.seed)), react.createElement('div', {
          className: 'description'
        }, children = react.createElement('span', {
          style: seedStyle
        }, children = " " + store.staking.chosenAccount.seed))
      ]), react.createElement('div', {
        className: 'section'
      }, children = [
        react.createElement('div', {
          className: 'title'
        }, children = react.createElement('h3', {}, ' ' + lang.rentExemptReserve)), react.createElement('div', {
          className: 'description'
        }, children = [
          react.createElement('span', {}, children = " " + store.staking.chosenAccount.rent + " VLX"), react.createElement('span', {
            className: 'usd-amount'
          }, children = " $" + usdRent)
        ])
      ]), react.createElement('div', {
        className: 'section'
      }, children = [
        react.createElement('div', {
          className: 'title'
        }, children = react.createElement('h3', {}, ' ' + lang.balance)), react.createElement('div', {
          className: 'description'
        }, children = [
          react.createElement('span', {}, children = " " + yourBalance + " VLX"), react.createElement('span', {
            className: 'usd-amount'
          }, children = " $" + usdBalance)
        ])
      ]), react.createElement('div', {}), react.createElement('div', {}), react.createElement('div', {
        className: 'section'
      }, children = react.createElement('div', {
        className: 'title'
      }, children = react.createElement('h2', {}, ' ' + lang.stakeDelegation))), react.createElement('div', {
        className: 'section'
      }, children = [
        react.createElement('div', {
          className: 'title'
        }, children = react.createElement('h3', {}, ' ' + lang.status)), react.createElement('div', {
          className: 'description'
        }, children = react.createElement('div', {
          title: store.staking.chosenAccount.status + "",
          className: 'chosen-account'
        }, children = react.createElement('span', {}, children = " " + $status)))
      ]), react.createElement('div', {
        className: 'section'
      }, children = [
        react.createElement('div', {
          className: 'title'
        }, children = react.createElement('h3', {}, ' ' + lang.validator)), react.createElement('div', {
          className: 'description'
        }, children = react.createElement('span', {
          className: 'chosen-account'
        }, children = [
          " " + $validator, store.staking.chosenAccount.validator !== "" ? react.createElement('img', {
            src: icons.imgCheck + "",
            className: 'check'
          }) : void 8
        ]))
      ]), react.createElement('div', {
        className: 'section'
      }, children = [
        react.createElement('div', {
          className: 'title'
        }, children = react.createElement('h3', {}, ' ' + lang.creditsObserved)), react.createElement('div', {
          className: 'description'
        }, children = react.createElement('span', {}, children = " " + credits_observed))
      ]), react.createElement('div', {
        className: 'section'
      }, children = [
        react.createElement('div', {
          className: 'title'
        }, children = react.createElement('h3', {}, ' ' + lang.delegatedStake)), react.createElement('div', {
          className: 'description'
        }, children = [
          react.createElement('span', {}, children = " " + roundHuman(delegated_stake) + " VLX"), react.createElement('span', {
            className: 'usd-amount'
          }, children = " $" + usdDelegated_stake)
        ])
      ]), react.createElement('div', {
        className: 'section'
      }, children = [
        react.createElement('div', {
          className: 'title'
        }, children = react.createElement('h3', {}, ' ' + lang.activeStake)), react.createElement('div', {
          className: 'description'
        }, children = [
          react.createElement('span', {}, children = " " + roundHuman(active_stake) + " VLX"), react.createElement('span', {
            className: 'usd-amount'
          }, children = " $" + usdActive_stake), store.staking.myStakeMaxPart != null && false ? react.createElement('span', {
            className: 'myStakeMaxPart'
          }, children = [
            react.createElement('div', {
              className: 'animation'
            }, children = [
              react.createElement('div', {
                className: 'anim-item'
              }, ' -'), react.createElement('div', {
                className: 'anim-item'
              }, ' -'), react.createElement('div', {
                className: 'anim-item'
              }, ' >')
            ]), " " + myStakeMaxPart
          ]) : void 8
        ])
      ]), react.createElement('div', {
        className: 'section'
      }, children = [
        react.createElement('div', {
          className: 'title'
        }, children = react.createElement('h3', {}, ' ' + inactiveStakeLabel)), react.createElement('div', {
          className: 'description'
        }, children = [
          react.createElement('span', {}, children = " " + roundHuman(inactive_stake) + " VLX"), react.createElement('span', {
            className: 'usd-amount'
          }, children = " $" + usdInactive_stake), store.staking.chosenAccount.status === "activating" ? (moreStyle = {
            textDecoration: "none",
            opacity: 0.8,
            lineHeight: 1.6,
            fontSize: "14px",
            letterSpacing: "2px",
            marginLeft: "5px"
          }, tipStyle = {
            color: "#16ffb2",
            opacity: 0.8
          }, linkStyle = {
            textDecoration: "none",
            color: "white",
            opacity: 0.8
          }, notificationStyle = {
            marginTop: "10px"
          }, react.createElement('div', {
            style: notificationStyle,
            className: 'notification'
          }, children = [
            react.createElement('span', {
              style: tipStyle
            }, ' Only 25% of active stake can be activated per epoch.'), react.createElement('a', {
              href: "https://support.velas.com/hc/en-150/articles/360021044820-Delegation-Warmup-and-Cooldown",
              target: "_blank",
              style: linkStyle
            }, children = react.createElement('span', {
              style: moreStyle
            }, ' More...'))
          ])) : void 8
        ])
      ]), react.createElement('div', {
        className: 'section'
      }, children = [
        react.createElement('div', {
          className: 'title'
        }, children = react.createElement('h2', {}, ' Actions')), react.createElement('div', {
          className: 'description'
        }, children = react.createElement('div', {
          className: 'buttons'
        }, children = [
          store.staking.chosenAccount.status === "inactive"
            ? react.createElement('div', {}, children = [
              button({
                store: store,
                onClick: delegate,
                type: 'secondary',
                text: lang.to_delegate,
                icon: 'arrowRight'
              }), button({
                store: store,
                onClick: withdraw,
                type: 'secondary',
                text: lang.withdraw,
                icon: 'arrowLeft'
              })
            ])
            : store.staking.chosenAccount.status !== 'deactivating' ? button({
              store: store,
              onClick: undelegate,
              type: 'secondary',
              text: lang.to_undelegate,
              icon: 'arrowLeft',
              classes: "action-undelegate"
            }) : void 8, button({
            store: store,
            onClick: splitAccount,
            type: 'secondary',
            text: lang.to_split,
            classes: "action-split",
            noIcon: true
          })
        ]))
      ]), react.createElement('div', {
        className: 'section rewards'
      }, children = [
        react.createElement('div', {
          className: 'title'
        }, children = react.createElement('h2', {}, ' ' + lang.uRewards)), react.createElement('div', {
          className: 'table-scroll'
        }, children = react.createElement('table', {}, children = [
          react.createElement('thead', {}, children = react.createElement('tr', {}, children = [
            react.createElement('td', {
              width: "3%",
              style: stakerPoolStyle,
              title: "Epoch"
            }, ' ' + lang.epoch + ' (?)'), react.createElement('td', {
              width: "25%",
              style: stats,
              title: "Reward Slot"
            }, ' Reward Slot (?)'), react.createElement('td', {
              width: "25%",
              style: stats,
              title: "Amount"
            }, ' ' + lang.amount + ' (?)'), react.createElement('td', {
              width: "25%",
              style: stats,
              title: "New Balance"
            }, ' ' + lang.newBalance + ' (?)'), react.createElement('td', {
              width: "7%",
              style: stats,
              title: "Percent Change"
            }, ' Percent Change (?)'), react.createElement('td', {
              width: "7%",
              style: stats,
              title: "APR"
            }, ' APR (?)')
          ])), react.createElement('tbody', {}, children = map(buildRewards)(
          store.staking.chosenAccount.rewards))
        ])), rewardsStats({
          store: store,
          web3t: web3t
        })
      ])
    ]));
  };
  accountDetails = function(arg$){
    var store, web3t, lang, goBack, gotoSearch, info, style, borderStyle, borderStyle2, borderRight, headerTableStyle, lightText, iconColor, showClass, justGoBack, children;
    store = arg$.store, web3t = arg$.web3t;
    lang = getLang(store);
    goBack = historyFuncs(store, web3t).goBack;
    gotoSearch = function(){
      return navigate(store, web3t, 'search');
    };
    info = getPrimaryInfo(store);
    style = {
      background: info.app.wallet,
      color: info.app.text
    };
    borderStyle = {
      color: info.app.text,
      borderBottom: "1px solid " + info.app.border,
      background: info.app.background,
      backgroundColor: info.app.bgspare
    };
    borderStyle2 = {
      color: info.app.text,
      borderBottom: "1px solid " + info.app.border,
      background: "#4b2888"
    };
    borderRight = {
      color: info.app.text,
      borderRight: "1px solid " + info.app.border
    };
    headerTableStyle = {
      borderBottom: "1px solid " + info.app.border,
      background: info.app.walletLight
    };
    lightText = {
      color: info.app.color3
    };
    iconColor = {
      filter: info.app.iconFilter
    };
    showClass = store.current.openMenu ? 'hide' : "";
    justGoBack = function(){
      store.staking.getAccountsFromCashe = true;
      return goBack();
    };
    return react.createElement('div', {
      className: 'staking staking672871527'
    }, children = [
      react.createElement('div', {
        style: borderStyle,
        className: 'title'
      }, children = [
        react.createElement('div', {
          className: showClass + " header"
        }, ' ' + lang.delegateStake), react.createElement('div', {
          onClick: justGoBack,
          className: 'close'
        }, children = react.createElement('img', {
          src: icons.arrowLeft + "",
          style: iconColor,
          className: 'icon-svg'
        })), burger(store, web3t), epoch(store, web3t), switchAccount(store, web3t)
      ]), stakingContent(store, web3t)
    ]);
  };
  accountDetails.init = function(arg$, cb){
    var store, web3t, account, stakeAccounts;
    store = arg$.store, web3t = arg$.web3t;
    console.log("account-details.init");
    account = store.staking.chosenAccount;
    if (account == null) {
      return null;
    }
    store.staking.chosenAccount.rewards = [];
    stakeAccounts = store.staking.parsedProgramAccounts;
    asCallback(web3t.velas.NativeStaking.getCurrentEpochInfo(), function(err, epochInfo){
      if (err != null) {
        console.error(err);
      }
      store.staking.currentEpoch = epochInfo.epoch;
      return asCallback(web3t.velas.NativeStaking.getStakeActivation(store.staking.chosenAccount.address), function(err, stakeActivation){
        if (err == null && stakeActivation != null) {
          store.staking.chosenAccount.status = stakeActivation.state;
          store.staking.chosenAccount.active_stake = stakeActivation.active;
          store.staking.chosenAccount.inactive_stake = stakeActivation.inactive;
        }
        if (err != null) {
          return alert(store, err, cb);
        }
        return asCallback(web3t.velas.NativeStaking.getCurrentEpochInfo(), function(err, epochInfo){
          var epoch, blockHeight, slotIndex, slotsInEpoch, transactionCount, prevEpoch, activationEpoch, ref$, ref1$, ref2$, ref3$, ref4$, ref5$;
          if (err != null) {
            console.error(err);
          }
          if (err != null) {
            return cb(null);
          }
          epoch = epochInfo.epoch, blockHeight = epochInfo.blockHeight, slotIndex = epochInfo.slotIndex, slotsInEpoch = epochInfo.slotsInEpoch, transactionCount = epochInfo.transactionCount;
          prevEpoch = minus(epoch, 1);
          activationEpoch = (ref$ = store.staking.chosenAccount.account) != null ? (ref1$ = ref$.data) != null ? (ref2$ = ref1$.parsed) != null ? (ref3$ = ref2$.info) != null ? (ref4$ = ref3$.stake) != null ? (ref5$ = ref4$.delegation) != null ? ref5$.activationEpoch : void 8 : void 8 : void 8 : void 8 : void 8 : void 8;
          return fetchEpochRewards(account.address, activationEpoch, function(err, rewards){
            store.staking.chosenAccount.rewards = rewards;
            return cb(null);
          });
        });
      });
    });
  };
  stringify = function(value){
    if (value != null) {
      return roundHuman(parseFloat(div(value, Math.pow(10, 18))));
    } else {
      return '..';
    }
  };
  fetchEpochRewards = function(address, activationEpoch, cb){
    if (store.staking.chosenAccount.validator == null || store.staking.chosenAccount.validator.toString().length === 0) {
      return cb(null, []);
    }
    return asCallback(web3t.velas.NativeStaking.getEpochSchedule(), function(err, epochSchedule){
      var firstNormalEpoch, firstNormalSlot, leaderScheduleSlotOffset, slotsPerEpoch, warmup;
      if (err != null) {
        console.error(err);
      }
      firstNormalEpoch = epochSchedule.firstNormalEpoch, firstNormalSlot = epochSchedule.firstNormalSlot, leaderScheduleSlotOffset = epochSchedule.leaderScheduleSlotOffset, slotsPerEpoch = epochSchedule.slotsPerEpoch, warmup = epochSchedule.warmup;
      return asCallback(web3t.velas.NativeStaking.getSlot(), function(err, slot){
        if (err != null) {
          console.error(err);
        }
        return asCallback(web3t.velas.NativeStaking.getFirstAvailableBlock(), function(err, firstAvailableBlock){
          if (err != null) {
            console.error(err);
          }
          return asCallback(web3t.velas.NativeStaking.getCurrentEpochInfo(), function(err, epochInfo){
            var epoch, blockHeight, slotIndex, slotsInEpoch, transactionCount;
            if (err != null) {
              console.error(err);
            }
            if (err != null) {
              return cb(null);
            }
            epoch = epochInfo.epoch, blockHeight = epochInfo.blockHeight, slotIndex = epochInfo.slotIndex, slotsInEpoch = epochInfo.slotsInEpoch, transactionCount = epochInfo.transactionCount;
            return queryRewardsLoop(address, activationEpoch, firstNormalSlot, slotsPerEpoch, slotsInEpoch, firstAvailableBlock, firstNormalEpoch, epoch, function(err, rewards){
              return cb(null, rewards);
            });
          });
        });
      });
    });
  };
  prevEpochData = {
    epoch_start_time: null,
    rewards: null,
    first_confirmed_block: null
  };
  queryRewardsLoop = function(address, activationEpoch, firstNormalSlot, slotsPerEpoch, slotsInEpoch, firstAvailableBlock, firstNormalEpoch, epoch, cb){
    if (epoch < activationEpoch || epoch < 0) {
      return cb(null, []);
    }
    return get_first_slot_in_epoch(firstNormalSlot, slotsPerEpoch, slotsInEpoch, firstNormalEpoch, epoch, function(err, firstSlotInEpoch){
      var limit;
      limit = 1;
      return asCallback(web3t.velas.NativeStaking.getConfirmedBlocksWithLimit(firstSlotInEpoch, limit), function(err, result){
        var first_confirmed_block_in_epoch, ref$;
        first_confirmed_block_in_epoch = result != null ? (ref$ = result.result) != null ? ref$[0] : void 8 : void 8;
        return get_confirmed_block_with_encoding(first_confirmed_block_in_epoch, function(err, first_confirmed_block){
          var rewards, SECONDS_PER_DAY, epoch_start_time, epoch_end_time, wallclock_epoch_duration, wallclock_epochs_per_year, allRewards, ref$;
          rewards = [];
          SECONDS_PER_DAY = 86400;
          epoch_start_time = (function(){
            switch (false) {
            case first_confirmed_block != null:
              return 0;
            default:
              return first_confirmed_block.blockTime;
            }
          }());
          epoch_end_time = prevEpochData.epoch_start_time;
          wallclock_epoch_duration = (function(){
            switch (false) {
            case epoch_end_time != null:
              return 0;
            default:
              return minus(epoch_end_time, epoch_start_time);
            }
          }());
          wallclock_epochs_per_year = div(SECONDS_PER_DAY * 365, wallclock_epoch_duration);
          allRewards = (ref$ = prevEpochData.rewards) != null
            ? ref$
            : [];
          rewards = map(function(it){
            var percentChange, rateChange, apr;
            percentChange = times(div(it.lamports, it.postBalance), 100);
            percentChange = roundNumber(percentChange, {
              decimals: 2
            });
            rateChange = div(it.lamports, it.postBalance - it.lamports);
            apr = (function(){
              switch (false) {
              case epoch_end_time != null:
                return "0";
              default:
                return times(times(rateChange, wallclock_epochs_per_year), 100);
              }
            }());
            apr = roundNumber(apr, {
              decimals: 2
            });
            return {
              epoch: epoch,
              rewardSlot: prevEpochData.rewardSlot,
              amount: it.lamports,
              newBalance: it.postBalance,
              percentChange: percentChange + "%",
              apr: apr + "%",
              disabled: first_confirmed_block == null
            };
          })(
          filter(function(it){
            return it.pubkey === address;
          })(
          allRewards));
          prevEpochData.first_confirmed_block = first_confirmed_block;
          prevEpochData.epoch_start_time = first_confirmed_block != null ? first_confirmed_block.blockTime : void 8;
          prevEpochData.rewards = first_confirmed_block != null ? first_confirmed_block.rewards : void 8;
          prevEpochData.rewardSlot = firstSlotInEpoch;
          return queryRewardsLoop(address, activationEpoch, firstNormalSlot, slotsPerEpoch, slotsInEpoch, firstAvailableBlock, firstNormalEpoch, --epoch, function(err, rest){
            var all;
            all = rewards.concat(rest);
            return cb(null, all);
          });
        });
      });
    });
  };
  get_first_slot_in_epoch = function(firstNormalSlot, slotsPerEpoch, slotsInEpoch, firstNormalEpoch, epoch, cb){
    var limit, firstSlotInEpoch;
    limit = 1;
    firstSlotInEpoch = (epoch - firstNormalEpoch) * slotsPerEpoch + firstNormalSlot;
    return cb(null, firstSlotInEpoch);
  };
  tryGetExtraSlot = function(defaultResponse, newSlot, cb){
    var limit;
    if (defaultResponse != null) {
      return cb(null, defaultResponse);
    }
    limit = 1;
    return asCallback(web3t.velas.NativeStaking.getConfirmedBlocksWithLimit(newSlot, limit), function(err, result){
      var ref$;
      return cb(null, result != null ? (ref$ = result.result) != null ? ref$[0] : void 8 : void 8);
    });
  };
  get_confirmed_block_with_encoding = function(slot, cb){
    return asCallback(web3t.velas.NativeStaking.getConfirmedBlock(slot), function(err, confirmedBlock){
      if (err != null) {
        console.error(err);
      }
      return cb(null, confirmedBlock);
    });
  };
  retrieveRewardData = function(firstSlotInEpoch, firstNormalSlot, slotsPerEpoch, slotsInEpoch, firstAvailableBlock, firstNormalEpoch, epoch, cb){
    if (firstSlotInEpoch < firstAvailableBlock) {
      return cb("RPC node is out of history data");
    }
    return get_confirmed_block_with_encoding(firstSlotInEpoch, function(err, confirmed_block_with_encoding){
      return cb(null, confirmed_block_with_encoding);
    });
  };
  module.exports = accountDetails;
}).call(this);
