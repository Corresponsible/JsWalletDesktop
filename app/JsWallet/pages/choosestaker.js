// Generated by LiveScript 1.6.0
(function(){
  var react, reactDom, navigate, getPrimaryInfo, web3, bignumber, getLang, historyFuncs, icon, ref$, map, split, filter, find, foldl, sortBy, unique, head, each, div, times, plus, minus, velasNodeTemplate, hdkey, bip39, md5, menuFuncs, btoa, Buffer, copiedInform, copy, round5, ethToVlx, switchAccount, roundHuman, exitStake, icons, placeholder, claimStake, canMakeStaking, epoch, alert, button, addressHolder, alertTxn, amountField, moveStake, seedmem, burger, cb, getPair, toKeystore, showValidator, stakingContent, staking, fillPools, fillVotePower, fillPoolsInParallel, toString$ = {}.toString, slice$ = [].slice;
  react = require('react');
  reactDom = require('react-dom');
  navigate = require('../navigate.ls');
  getPrimaryInfo = require('../get-primary-info.ls');
  web3 = require('../web3.ls');
  bignumber = require('bignumber.js');
  getLang = require('../get-lang.ls');
  historyFuncs = require('../history-funcs.ls');
  icon = require('./icon.ls');
  ref$ = require('prelude-ls'), map = ref$.map, split = ref$.split, filter = ref$.filter, find = ref$.find, foldl = ref$.foldl, sortBy = ref$.sortBy, unique = ref$.unique, head = ref$.head, each = ref$.each;
  ref$ = require('../math.ls'), div = ref$.div, times = ref$.times, plus = ref$.plus, minus = ref$.minus;
  velasNodeTemplate = require('../velas/velas-node-template.ls');
  ref$ = require('../../web3t/providers/deps.js'), hdkey = ref$.hdkey, bip39 = ref$.bip39;
  md5 = require('md5');
  menuFuncs = require('../menu-funcs.ls');
  btoa = require('btoa');
  Buffer = require('safe-buffer').Buffer;
  copiedInform = require('../copied-inform.ls');
  copy = require('../copy.ls');
  round5 = require('../round5.ls');
  ethToVlx = require('../../web3t/addresses.js').ethToVlx;
  switchAccount = require('./switch-account.ls');
  roundHuman = require('../round-human.ls');
  exitStake = require('./exit-stake.ls');
  icons = require('../icons.ls');
  placeholder = require('./placeholder.ls');
  claimStake = require('./claim-stake.ls');
  canMakeStaking = require('../staking/can-make-staking.ls');
  epoch = require('./epoch.ls');
  alert = require('./confirmation.ls').alert;
  button = require('../components/button.ls');
  addressHolder = require('../components/address-holder.ls');
  alertTxn = require('./alert-txn.ls');
  amountField = require('../components/amount-field.ls');
  moveStake = require('./move-stake.ls');
  seedmem = require('../seed.ls');
  burger = require('../components/burger.ls');
  cb = console.log;
  getPair = function(wallet, path, index, password, withKeystore){
    var w, address, salt, iv, uuid, kdf, keystore;
    w = wallet.derivePath(path).deriveChild(index).getWallet();
    address = "0x" + w.getAddress().toString('hex');
    salt = Buffer.from('dc9e4a98886738bd8aae134a1f89aaa5a502c3fbd10e336136d4d5fe47448ad6', 'hex');
    iv = Buffer.from('cecacd85e9cb89788b5aab2f93361233', 'hex');
    uuid = Buffer.from('7e59dc028d42d09db29aa8a0f862cc81', 'hex');
    kdf = 'pbkdf2';
    keystore = (function(){
      switch (false) {
      case !withKeystore:
        return w.toV3String(password, {
          salt: salt,
          iv: iv,
          uuid: uuid,
          kdf: kdf
        });
      default:
        return "";
      }
    }());
    return {
      address: address,
      keystore: keystore
    };
  };
  toKeystore = function(store, withKeystore){
    var mnemonic, seed, wallet, index, password, staking, mining;
    mnemonic = seedmem.mnemonic;
    seed = bip39.mnemonicToSeed(mnemonic);
    wallet = hdkey.fromMasterSeed(seed);
    index = store.current.accountIndex;
    password = md5(wallet.derivePath("m1").deriveChild(index).getWallet().getAddress().toString('hex'));
    staking = (function(){
      switch (false) {
      case store.urlParams.anotheracc == null:
        return {
          address: window.toEthAddress(store.urlParams.anotheracc)
        };
      default:
        return getPair(wallet, 'm0', index, password, false);
      }
    }());
    mining = getPair(wallet, 'm0/2', index, password, withKeystore);
    return {
      staking: staking,
      mining: mining,
      password: password
    };
  };
  showValidator = function(store, web3t){
    return function(validator){
      return react.createElement('li', {}, ' ' + validator);
    };
  };
  stakingContent = function(store, web3t){
    var goBack, style, lang, buttonPrimary3Style, filterIcon, commingSoon, pairs, iStakeChoosenPool, becomeValidator, changeAddress, changeStake, velasNodeAppliedTemplate, velasNodeAppliedTemplateLine, showScript, ref$, accountLeft, accountRight, changeAccountIndex, updateCurrent, accountLeftProxy, accountRightProxy, changeAccountIndexProxy, buildTemplateLine, lineStyle, activate, activateLine, activateString, activateSsh, activateDo, activeClass, activeLine, activeString, activeSsh, activeDo, getBalance, getOptions, useMin, useMax, voteForChange, yourBalance, yourStakingAmount, yourStaking, vlxToken, buildStaker, cancelPool, activateFirst, activateSecond, activateThird, activeFirst, activeSecond, activeThird, refresh, iconStyle, stakerPoolStyle, stats, children;
    goBack = historyFuncs(store, web3t).goBack;
    style = getPrimaryInfo(store);
    lang = getLang(store);
    buttonPrimary3Style = {
      border: "1px solid " + style.app.primary3,
      color: style.app.text2,
      background: style.app.primary3,
      backgroundColor: style.app.primary3Spare
    };
    filterIcon = {
      filter: style.app.filterIcon
    };
    commingSoon = {
      opacity: ".3"
    };
    pairs = store.staking.keystore;
    iStakeChoosenPool = function(){
      var pool, myStake;
      pool = store.staking.chosenPool;
      myStake = +pool.myStake;
      return myStake >= 10000;
    };
    becomeValidator = function(){
      return getOptions(function(err, options){
        if (err != null) {
          return alert(store, err, cb);
        }
        return canMakeStaking(store, web3t, function(err){
          var type, stake, data, to, amount;
          if (err != null) {
            return alert(store, err, cb);
          }
          if (store.staking.chosenPool == null) {
            return alert(store, "please choose the pool", cb);
          }
          type = toString$.call(store.staking.add.addValidatorStake).slice(8, -1);
          if (type !== 'String' && type !== 'Number') {
            return alert(store, "please enter correct amount, got " + type, cb);
          }
          stake = times(store.staking.add.addValidatorStake, Math.pow(10, 18));
          data = web3t.velas.Staking.stake.getData(store.staking.chosenPool.address, stake);
          to = web3t.velas.Staking.address;
          amount = store.staking.add.addValidatorStake;
          return web3t.vlx2.sendTransaction({
            to: to,
            data: data,
            amount: amount
          }, function(err){
            if (err != null) {
              return store.staking.add.result = err + "";
            }
            return staking.init({
              store: store,
              web3t: web3t
            }, function(){});
          });
        });
      });
    };
    changeAddress = function(it){
      return store.staking.add.addValidator = it.target.value;
    };
    changeStake = function(it){
      var value, err;
      try {
        value = new bignumber(it.target.value).toFixed().toString();
        store.staking.add.addValidatorStake = value;
      } catch (e$) {
        err = e$;
        console.log("[Change-stake]: " + err);
      }
    };
    velasNodeAppliedTemplate = split("\n")(
    velasNodeTemplate(
    pairs));
    velasNodeAppliedTemplateLine = function(it){
      return "echo '" + it + "' | base64 --decode | sh";
    }(
    btoa(
    velasNodeTemplate(
    pairs)));
    if (pairs.mining == null) {
      return null;
    }
    showScript = function(){
      return store.staking.keystore = toKeystore(store, true);
    };
    ref$ = menuFuncs(store, web3t), accountLeft = ref$.accountLeft, accountRight = ref$.accountRight, changeAccountIndex = ref$.changeAccountIndex;
    updateCurrent = function(func){
      return function(data){
        func(data);
        return staking.init({
          store: store,
          web3t: web3t
        }, function(){
          return store.staking.keystore = toKeystore(store, false);
        });
      };
    };
    accountLeftProxy = updateCurrent(accountLeft);
    accountRightProxy = updateCurrent(accountRight);
    changeAccountIndexProxy = updateCurrent(changeAccountIndex);
    buildTemplateLine = function(it){
      var index, lineStyle;
      index = velasNodeAppliedTemplate.indexOf(it);
      lineStyle = {
        padding: "10px",
        width: '100%',
        marginBottom: '2px',
        background: index % 2 ? 'rgba(255, 255, 255, 0.04)' : ''
      };
      return react.createElement('div', {
        style: lineStyle
      }, ' ' + it);
    };
    lineStyle = {
      padding: "10px",
      width: '100%'
    };
    activate = function(tab){
      return function(){
        return store.staking.tab = tab;
      };
    };
    activateLine = activate('line');
    activateString = activate('string');
    activateSsh = activate('ssh');
    activateDo = activate('do');
    activeClass = function(tab){
      if (store.staking.tab === tab) {
        return 'active';
      } else {
        return '';
      }
    };
    activeLine = activeClass('line');
    activeString = activeClass('string');
    activeSsh = activeClass('ssh');
    activeDo = activeClass('do');
    getBalance = function(){
      var wallet;
      wallet = find(function(it){
        return it.coin.token === 'vlx2';
      })(
      store.current.account.wallets);
      return wallet.balance;
    };
    getOptions = function(cb){
      var iAmStaker, min, max;
      iAmStaker = iStakeChoosenPool();
      if (iAmStaker) {
        return cb(null);
      }
      min = 10000;
      max = minus(getBalance(), 0.1);
      if (+min > +max) {
        return cb(lang.balanceLessStaking);
      }
      return cb(null, {
        min: min,
        max: max
      });
    };
    useMin = function(){
      return getOptions(function(err, options){
        if (err != null) {
          return alert(store, err, cb);
        }
        return store.staking.add.addValidatorStake = options.min;
      });
    };
    useMax = function(){
      return getOptions(function(err, options){
        if (err != null) {
          return alert(store, err, cb);
        }
        return store.staking.add.addValidatorStake = options.max;
      });
    };
    voteForChange = function(){
      return web3t.velas.ValidatorSet.emitInitiateChangeCallable(function(err, can){
        var data, to, amount;
        if (err != null) {
          return alert(store, err, cb);
        }
        if (can !== true) {
          return alert(store, lang.actionProhibited, cb);
        }
        data = web3t.velas.ValidatorSet.emitInitiateChange.getData();
        to = web3t.velas.ValidatorSet.address;
        amount = 0;
        return web3t.vlx2.sendTransaction({
          to: to,
          data: data,
          amount: amount
        }, function(err){
          return store.current.page = 'staking';
        });
      });
    };
    yourBalance = " " + roundHuman(getBalance()) + " ";
    yourStakingAmount = div(store.staking.stakeAmountTotal, Math.pow(10, 18));
    yourStaking = " " + roundHuman(yourStakingAmount);
    vlxToken = "VLX2";
    buildStaker = function(store, web3t){
      return function(item){
        var checked, stake, myStake, index, choosePull, toEth, reward, filled, filledColor, vlx2, wallet, votePower, children;
        checked = item.checked;
        stake = roundHuman(item.stake);
        myStake = (function(){
          switch (false) {
          case +item.myStake !== 0:
            return roundHuman(item.withdrawAmount);
          default:
            return roundHuman(item.myStake);
          }
        }());
        index = store.staking.pools.indexOf(item) + 1;
        choosePull = function(){
          var page, cb, stakingAddress;
          page = 'choosestaker-pool';
          if (store.pages.length > 0 && page !== store.pages[store.pages.length - 1]) {
            store.pages.push(page);
          }
          cb = function(err, data){
            if (err != null) {
              return alert(store, err, bind$(console, 'log'));
            }
          };
          map(function(it){
            return it.checked = false;
          })(
          store.staking.pools);
          item.checked = true;
          store.staking.chosenPool = item;
          store.staking.add.newAddress = "";
          claimStake.calcReward(store, web3t);
          stakingAddress = store.staking.keystore.staking.address;
          return web3t.velas.Staking.stakeAmount(item.address, stakingAddress, function(err, amount){
            if (err != null) {
              return cb(err);
            }
            store.staking.stakeAmountTotal = amount.toFixed();
            return exitStake.init({
              store: store,
              web3t: web3t
            }, function(err){
              if (err != null) {
                return cb(err);
              }
            });
          });
        };
        toEth = function(){
          return item.eth = !item.eth;
        };
        reward = (function(){
          switch (false) {
          case item.validatorRewardPercent !== "..":
            return "..";
          default:
            return (100 - +item.validatorRewardPercent) * 1.4285714286;
          }
        }());
        filled = roundHuman(reward) + "%";
        filledColor = {
          color: (function(){
            switch (false) {
            case !(reward > 95):
              return 'red';
            case !(reward > 75):
              return 'orange';
            case !(reward > 40):
              return "rgb(165, 174, 81)";
            default:
              return "rgb(38, 219, 85)";
            }
          }())
        };
        vlx2 = find(function(it){
          return it.coin.token === 'vlx2';
        })(
        store.current.account.wallets);
        wallet = {
          address: ethToVlx(item.address),
          network: vlx2.network,
          coin: vlx2.coin
        };
        votePower = (function(){
          switch (false) {
          case item.votePower == null:
            return item.votePower + "%";
          default:
            return "...";
          }
        }());
        return react.createElement('tr', {
          className: item.status + ""
        }, children = [
          react.createElement('td', {}, children = react.createElement('span', {
            className: item.status + " circle"
          }, ' ' + index)), react.createElement('td', {
            dataColumn: 'Staker Address',
            title: ethToVlx(item.address) + ""
          }, children = addressHolder({
            store: store,
            wallet: wallet
          })), react.createElement('td', {
            dataColumn: 'Amount'
          }, ' ' + stake), react.createElement('td', {}, ' ' + votePower), react.createElement('td', {
            dataColumn: 'Amount'
          }, ' ' + myStake), react.createElement('td', {
            dataColumn: 'Stakers'
          }, ' ' + item.stakers), react.createElement('td', {}, children = button({
            store: store,
            onClick: choosePull,
            type: 'secondary',
            icon: 'arrowRight'
          }))
        ]);
      };
    };
    cancelPool = function(){
      goBack();
      return store.staking.chosenPool = null;
    };
    activate = function(step){
      return function(){
        return store.current.step = step;
      };
    };
    activateFirst = activate('first');
    activateSecond = activate('second');
    activateThird = activate('third');
    activeClass = function(step){
      if (store.current.step === step) {
        return 'active';
      } else {
        return '';
      }
    };
    activeFirst = activeClass('first');
    activeSecond = activeClass('second');
    activeThird = activeClass('third');
    refresh = function(){
      var cb;
      cb = console.log;
      store.staking.pools.length = 0;
      return staking.init({
        store: store,
        web3t: web3t
      }, function(err){
        if (err != null) {
          return cb(err);
        }
        return staking.focus({
          store: store,
          web3t: web3t
        }, function(err){
          if (err != null) {
            return cb(err);
          }
          return cb(null, 'done');
        });
      });
    };
    iconStyle = {
      color: style.app.loader,
      marginTop: "10px",
      width: "inherit"
    };
    stakerPoolStyle = {
      maxWidth: 200,
      background: style.app.stats
    };
    stats = {
      background: style.app.stats
    };
    return react.createElement('div', {
      className: 'staking-content delegate'
    }, children = react.createElement('div', {
      className: 'form-group'
    }, children = [
      alertTxn({
        store: store
      }), react.createElement('div', {
        className: 'section'
      }, children = [
        react.createElement('div', {
          className: 'title'
        }, children = [
          react.createElement('h3', {}, ' ' + lang.selectPool), store.staking.chosenPool == null ? react.createElement('div', {}, children = react.createElement('div', {
            onClick: refresh,
            style: iconStyle,
            title: "refresh",
            className: 'loader'
          }, children = icon('Sync', 25))) : void 8
        ]), store.staking.chosenPool == null
          ? react.createElement('div', {
            className: 'description table-scroll'
          }, children = react.createElement('table', {}, children = [
            react.createElement('thead', {}, children = react.createElement('tr', {}, children = [
              react.createElement('th', {
                width: "3%",
                style: stats
              }, ' #'), react.createElement('th', {
                width: "10%",
                style: stakerPoolStyle
              }, ' ' + lang.stakerPool), react.createElement('th', {
                width: "25%",
                style: stats
              }, ' ' + lang.totalStake), react.createElement('th', {
                width: "5%",
                style: stats
              }, ' ' + lang.votePower), react.createElement('th', {
                width: "25%",
                style: stats
              }, ' ' + lang.myStake), react.createElement('th', {
                width: "5%",
                style: stats
              }, ' ' + lang.stakers), react.createElement('th', {
                width: "4%",
                style: stats
              }, ' ' + lang.selectPool)
            ])), react.createElement('tbody', {}, children = map(buildStaker(store, web3t))(
            store.staking.pools))
          ]))
          : react.createElement('div', {
            title: store.staking.chosenPool + "",
            className: 'chosen-pool'
          }, children = [
            react.createElement('span', {}, children = [
              " " + ethToVlx(store.staking.chosenPool.address), react.createElement('img', {
                src: icons.imgCheck + "",
                className: 'check'
              })
            ]), react.createElement('div', {
              className: 'buttons'
            }, children = button({
              store: store,
              onClick: cancelPool,
              type: 'secondary',
              icon: 'choose',
              text: lang.btnSelect + ""
            }))
          ])
      ]), store.staking.chosenPool != null && +store.staking.stakeAmountTotal === 0 ? react.createElement('div', {
        className: 'section'
      }, children = [
        react.createElement('div', {
          className: 'title'
        }, children = react.createElement('h3', {}, ' ' + lang.validator)), react.createElement('div', {
          className: 'description'
        }, children = [
          react.createElement('div', {
            className: 'left'
          }, children = [
            react.createElement('label', {}, ' ' + lang.stake), amountField({
              store: store,
              value: store.staking.add.addValidatorStake,
              onChange: changeStake,
              placeholder: lang.stake
            }), react.createElement('div', {
              className: 'balance'
            }, children = [
              react.createElement('span', {
                className: 'small-btns'
              }, children = [
                react.createElement('button', {
                  style: buttonPrimary3Style,
                  onClick: useMin,
                  className: 'small'
                }, ' ' + lang.min), react.createElement('button', {
                  style: buttonPrimary3Style,
                  onClick: useMax,
                  className: 'small'
                }, ' ' + lang.max)
              ]), react.createElement('span', {}, ' ' + lang.balance + ':'), react.createElement('span', {
                className: 'color'
              }, ' ' + yourBalance), react.createElement('img', {
                src: icons.vlxIcon + "",
                className: 'label-coin'
              }), react.createElement('span', {
                className: 'color'
              }, ' ' + vlxToken)
            ])
          ]), button({
            store: store,
            onClick: becomeValidator,
            type: 'secondary',
            icon: 'apply',
            text: 'btnApply'
          })
        ])
      ]) : void 8, store.staking.chosenPool != null && +store.staking.stakeAmountTotal > 0 ? react.createElement('div', {
        className: 'section'
      }, children = [
        react.createElement('div', {
          className: 'title'
        }, children = react.createElement('h3', {}, ' ' + lang.staking)), react.createElement('div', {
          className: 'description'
        }, children = [
          react.createElement('div', {
            className: 'left'
          }, children = [
            react.createElement('div', {
              className: 'balance'
            }, children = [
              react.createElement('span', {}, ' ' + lang.yourStaking + ':'), react.createElement('span', {
                className: 'color'
              }, ' ' + yourStaking), react.createElement('span', {
                className: 'color'
              }, ' ' + vlxToken)
            ]), react.createElement('hr', {}), react.createElement('label', {}, ' ' + lang.stakeMore), amountField({
              store: store,
              value: store.staking.add.addValidatorStake,
              onChange: changeStake,
              placeholder: lang.stake
            }), react.createElement('div', {
              className: 'balance'
            }, children = [
              react.createElement('span', {
                className: 'small-btns'
              }, children = [
                react.createElement('button', {
                  style: buttonPrimary3Style,
                  onClick: useMin,
                  className: 'small'
                }, ' ' + lang.min), react.createElement('button', {
                  style: buttonPrimary3Style,
                  onClick: useMax,
                  className: 'small'
                }, ' ' + lang.max)
              ]), react.createElement('span', {}, ' ' + lang.balance + ':'), react.createElement('span', {
                className: 'color'
              }, ' ' + yourBalance), react.createElement('img', {
                src: icons.vlxIcon + "",
                className: 'label-coin'
              }), react.createElement('span', {
                className: 'color'
              }, ' ' + vlxToken)
            ])
          ]), button({
            store: store,
            onClick: becomeValidator,
            type: 'secondary',
            icon: 'apply',
            text: 'btnApply'
          })
        ])
      ]) : void 8, claimStake(store, web3t), exitStake(store, web3t), moveStake(store, web3t)
    ]));
  };
  staking = function(arg$){
    var store, web3t, lang, goBack, gotoSearch, info, style, borderStyle, borderStyle2, borderRight, headerTableStyle, lightText, iconColor, showClass, children;
    store = arg$.store, web3t = arg$.web3t;
    lang = getLang(store);
    goBack = historyFuncs(store, web3t).goBack;
    gotoSearch = function(){
      return navigate(store, web3t, 'search');
    };
    info = getPrimaryInfo(store);
    style = {
      background: info.app.wallet,
      color: info.app.text
    };
    borderStyle = {
      color: info.app.text,
      borderBottom: "1px solid " + info.app.border,
      background: info.app.background,
      backgroundColor: info.app.bgspare
    };
    borderStyle2 = {
      color: info.app.text,
      borderBottom: "1px solid " + info.app.border,
      background: "#4b2888"
    };
    borderRight = {
      color: info.app.text,
      borderRight: "1px solid " + info.app.border
    };
    headerTableStyle = {
      borderBottom: "1px solid " + info.app.border,
      background: info.app.walletLight
    };
    lightText = {
      color: info.app.color3
    };
    iconColor = {
      filter: info.app.iconFilter
    };
    showClass = store.current.openMenu ? 'hide' : "";
    return react.createElement('div', {
      className: 'staking staking-1597922539'
    }, children = [
      react.createElement('div', {
        style: borderStyle,
        className: 'title'
      }, children = [
        react.createElement('div', {
          className: showClass + " header"
        }, ' ' + lang.delegateStake), react.createElement('div', {
          onClick: goBack,
          className: 'close'
        }, children = react.createElement('img', {
          src: icons.arrowLeft + "",
          style: iconColor,
          className: 'icon-svg'
        })), burger(store, web3t), epoch(store, web3t), switchAccount(store, web3t)
      ]), stakingContent(store, web3t)
    ]);
  };
  staking.init = function(arg$, cb){
    var store, web3t, random;
    store = arg$.store, web3t = arg$.web3t;
    store.staking.maxWithdraw = 0;
    random = function(){
      return Math.random();
    };
    store.staking.withdrawAmount = 0;
    store.staking.stakeAmountTotal = 0;
    store.staking.keystore = toKeystore(store, false);
    store.staking.reward = null;
    store.staking.chosenPool = null;
    store.staking.add.addValidatorStake = 0;
    if (store.staking.pools.length > 0) {
      return cb(null);
    }
    return web3t.velas.Staking.getPoolsInactive(function(err, poolsInactive){
      if (err != null) {
        return cb(err);
      }
      return web3t.velas.Staking.getPools(function(err, pools){
        if (err != null) {
          return cb(err);
        }
        return web3t.velas.Staking.getPoolsToBeElected(function(err, activePools){
          var allPools;
          if (err != null) {
            return cb(err);
          }
          store.staking.poolsInactive = poolsInactive;
          store.staking.poolsActive = activePools;
          allPools = pools.concat(poolsInactive);
          store.staking.pools = map(function(it){
            return {
              address: it,
              checked: false,
              stake: '..',
              stakers: '..',
              eth: false,
              isValidator: '..',
              status: '',
              rewardAmount: '..',
              validatorRewardPercent: '..',
              myStake: '..'
            };
          })(
          unique(
          allPools));
          return web3t.velas.Staking.stakingEpoch(function(err, epoch){
            store.staking.epoch = epoch.toFixed();
            return exitStake.init({
              store: store,
              web3t: web3t
            }, function(err){
              return cb(null);
            });
          });
        });
      });
    });
  };
  module.exports = staking;
  fillPools = function(arg$, arg1$, cb){
    var store, web3t, item, rest, stakingAddress;
    store = arg$.store, web3t = arg$.web3t;
    item = arg1$[0], rest = slice$.call(arg1$, 1);
    stakingAddress = store.staking.keystore.staking.address;
    if (item == null) {
      return cb(null);
    }
    return web3t.velas.Staking.stakeAmountTotal(item.address, function(err, data){
      if (err != null) {
        return cb(err);
      }
      item.stake = div(data, Math.pow(10, 18));
      return web3t.velas.Staking.poolDelegators(item.address, function(err, delegators){
        if (err != null) {
          return cb(err);
        }
        item.stakers = delegators.length + 1;
        return web3t.velas.ValidatorSet.miningByStakingAddress(item.address, function(err, miningAddress){
          if (err != null) {
            return cb(err);
          }
          item.miningAddress = miningAddress;
          return web3t.velas.BlockReward.validatorRewardPercent(item.address, function(err, validatorRewardPercent){
            if (err != null) {
              return cb(err);
            }
            item.validatorRewardPercent = div(validatorRewardPercent, 10000);
            return web3t.velas.ValidatorSet.isValidatorBanned(miningAddress, function(err, isValidatorBanned){
              if (err != null) {
                return cb(err);
              }
              return web3t.velas.Staking.stakeAmount(item.address, stakingAddress, function(err, amount){
                if (err != null) {
                  return cb(err);
                }
                return web3t.velas.Staking.orderedWithdrawAmount(item.address, stakingAddress, function(err, withdrawAmount){
                  if (err != null) {
                    return cb(err);
                  }
                  item.withdrawAmount = div(withdrawAmount, Math.pow(10, 18));
                  item.myStake = div(amount, Math.pow(10, 18));
                  item.status = (function(){
                    switch (false) {
                    case !isValidatorBanned:
                      return 'banned';
                    case !(store.staking.poolsActive.indexOf(item.address) > -1):
                      return 'active';
                    case !(store.staking.poolsInactive.indexOf(item.address) > -1):
                      return 'inactive';
                    default:
                      return 'pending';
                    }
                  }());
                  return fillPools({
                    store: store,
                    web3t: web3t
                  }, rest, cb);
                });
              });
            });
          });
        });
      });
    });
  };
  fillVotePower = function(arg$, cb){
    var store, web3t, totalStake, totalStakePercent, fillPower;
    store = arg$.store, web3t = arg$.web3t;
    totalStake = foldl(plus, 0)(
    map(function(it){
      return it.stake;
    })(
    store.staking.pools));
    totalStakePercent = div(100, totalStake);
    fillPower = function(it){
      return it.votePower = round5(times(it.stake, totalStakePercent));
    };
    each(fillPower)(
    store.staking.pools);
    return cb(null);
  };
  fillPoolsInParallel = function(arg$, cb){
    var store, web3t, createPromise, promises;
    store = arg$.store, web3t = arg$.web3t;
    createPromise = function(pool){
      return new Promise(function(resolve, reject){
        var cb;
        cb = function(err, value){
          return resolve(value);
        };
        return fillPools({
          store: store,
          web3t: web3t
        }, [pool], cb);
      });
    };
    promises = map(createPromise)(
    store.staking.pools);
    return Promise.all(promises).then(function(values){
      return cb(null);
    });
  };
  staking.focus = function(arg$, cb){
    var store, web3t;
    store = arg$.store, web3t = arg$.web3t;
    console.log('Filling');
    return fillPools({
      store: store,
      web3t: web3t
    }, store.staking.pools, function(err){
      if (err != null) {
        return cb(err);
      }
      return fillVotePower({
        store: store,
        web3t: web3t
      }, function(err){
        return cb(null);
      });
    });
  };
  function bind$(obj, key, target){
    return function(){ return (target || obj)[key].apply(obj, arguments) };
  }
}).call(this);
