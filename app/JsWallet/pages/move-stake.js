// Generated by LiveScript 1.6.0
(function(){
  var react, amountField, textField, button, alert, canMakeStaking, ref$, vlxToEth, ethToVlx, getLang, div, times, plus, minus, tryParseAddress;
  react = require('react');
  amountField = require('../components/amount-field.ls');
  textField = require('../components/text-field.ls');
  button = require('../components/button.ls');
  alert = require('./confirmation.ls').alert;
  canMakeStaking = require('../staking/can-make-staking.ls');
  ref$ = require('../../web3t/addresses.js'), vlxToEth = ref$.vlxToEth, ethToVlx = ref$.ethToVlx;
  getLang = require('../get-lang.ls');
  ref$ = require('../math.ls'), div = ref$.div, times = ref$.times, plus = ref$.plus, minus = ref$.minus;
  tryParseAddress = function(address, cb){
    var err;
    try {
      return cb(null, vlxToEth(address));
    } catch (e$) {
      err = e$;
      return cb(err);
    }
  };
  module.exports = function(store, web3t){
    var stakingAddress, ref$, lang, cb, moveStake, changeStake, changeAddress, children;
    if (store.staking.chosenPool == null) {
      return null;
    }
    if (+store.staking.stakeAmountTotal === 0) {
      return null;
    }
    stakingAddress = (ref$ = store.staking.keystore.staking) != null ? ref$.address : void 8;
    if (stakingAddress == null) {
      return null;
    }
    lang = getLang(store);
    cb = console.log;
    moveStake = function(){
      var poolAddress;
      poolAddress = store.staking.chosenPool.address;
      return tryParseAddress(store.staking.add.newAddress, function(err, newPoolAddress){
        if (err != null) {
          return alert(store, err, cb);
        }
        return canMakeStaking(store, web3t, function(err){
          var stake;
          if (err != null) {
            return alert(store, err, cb);
          }
          stake = store.staking.add.moveStake;
          return web3t.velas.Staking.maxWithdrawAllowed(poolAddress, stakingAddress, function(err, max){
            var maxAllowed, data, to;
            if (err != null) {
              return alert(store, err, cb);
            }
            maxAllowed = div(max.toFixed(), Math.pow(10, 18));
            if (+stake > +maxAllowed) {
              return alert(store, "stake must be lower or equal to max allowed " + maxAllowed, cb);
            }
            data = web3t.velas.Staking.moveStake.getData(poolAddress, newPoolAddress, stake);
            to = web3t.velas.Staking.address;
            return web3t.vlx2.sendTransaction({
              to: to,
              data: data,
              amount: 0
            }, function(err){});
          });
        });
      });
    };
    changeStake = function(it){
      return store.staking.add.moveStake = it.target.value;
    };
    changeAddress = function(it){
      return store.staking.add.newAddress = it.target.value;
    };
    return react.createElement('div', {
      className: 'section'
    }, children = [
      react.createElement('div', {
        className: 'title'
      }, children = react.createElement('h3', {}, ' ' + lang.moveStake)), react.createElement('div', {
        className: 'description'
      }, children = [
        react.createElement('div', {}, children = [
          react.createElement('label', {}, ' ' + lang.moveAmount), amountField({
            store: store,
            value: store.staking.add.moveStake,
            onChange: changeStake,
            placeholder: lang.stake
          })
        ]), react.createElement('div', {}, children = [
          react.createElement('label', {}, ' ' + lang.newPoolAddress), textField({
            store: store,
            value: store.staking.add.newAddress,
            onChange: changeAddress,
            placeholder: lang.stake
          })
        ]), react.createElement('div', {}, children = button({
          store: store,
          onClick: moveStake,
          type: 'secondary',
          icon: 'apply',
          text: 'btnApply'
        }))
      ])
    ]);
  };
}).call(this);
